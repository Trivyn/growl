;; ============================================================
;; Growl CLI - OWL 2 RL Reasoner Command-Line Interface
;;
;; Usage: growl [options] <file.ttl>
;;   --quiet       Only print failures and inconsistencies
;;   --fast        Skip schema rules and consistency checks
;;   --emit <file> Write materialized graph to TTL file
;; ============================================================

(module main
  (@doc "CLI interface for growl OWL 2 RL reasoner")

  (import rdf (Term Triple Graph GraphSize make-graph graph-size make-iri term-eq
               triple-predicate triple-object))
  (import index (IndexedGraph indexed-graph-create indexed-graph-add
                 indexed-graph-size))
  (import ttl (PrefixMap PrefixBinding make-prefix-map parse-ttl-file TtlFileError))
  (import common (ParseError Position))
  (import serialize-ttl (SerializeConfig serialize-ttl-stream))
  (import growl (reason reason-with-config ReasonerConfig ReasonerResult ReasonerSuccess InconsistencyReport
                 get-inferred-count default-config
                 collect-annotation-properties graph-to-indexed indexed-to-graph))

  (ffi "string.h"
    (strlen ((s (Ptr U8))) U64))

  (ffi "slop_runtime.h"
    (slop_now_ms (() I64)))

  ;; ============================================================
  ;; Timing Helpers
  ;; ============================================================

  (fn print-elapsed ((arena Arena) (elapsed I64))
    (@intent "Print elapsed time in seconds with milliseconds")
    (@spec ((Arena I64) -> Unit))
    (print (int-to-string arena (/ elapsed 1000)))
    (print ".")
    (let ((ms (% elapsed 1000)))
      ;; Pad with leading zeros if needed
      (when (< ms 100)
        (print "0"))
      (when (< ms 10)
        (print "0"))
      (print (int-to-string arena ms)))
    (print "s"))

  ;; ============================================================
  ;; Argument Parsing
  ;; ============================================================

  (type CliArgs (record
    (input-file (Option String))
    (emit-file (Option String))
    (background-file (Option String))
    (validate-ns (Option String))
    (quiet Bool)
    (fast Bool)
    (complete Bool)
    (validate Bool)
    (show-help Bool)
    (show-version Bool)))

  (fn argv-to-string ((argv (Ptr (Ptr U8))) (index Int))
    (@intent "Convert argv[index] to a SLOP String")
    (@spec (((Ptr (Ptr U8)) Int) -> String))
    (let ((ptr (@ argv index)))
      (String ptr (strlen ptr))))

  (fn parse-args ((arena Arena) (argc Int) (argv (Ptr (Ptr U8))))
    (@intent "Parse command-line arguments into CliArgs")
    (@spec ((Arena Int (Ptr (Ptr U8))) -> CliArgs))
    (@alloc arena)
    (let ((mut input (Option String) (none))
          (mut emit (Option String) (none))
          (mut background (Option String) (none))
          (mut validate-ns-opt (Option String) (none))
          (mut quiet false)
          (mut fast false)
          (mut complete false)
          (mut validate false)
          (mut help false)
          (mut version false)
          (mut i 1))
      (while (< i argc)
        (let ((arg (argv-to-string argv i)))
          (cond
            ((or (string-eq arg "--help") (string-eq arg "-h"))
              (set! help true)
              (set! i (+ i 1)))
            ((or (string-eq arg "--version") (string-eq arg "-V"))
              (set! version true)
              (set! i (+ i 1)))
            ((or (string-eq arg "--quiet") (string-eq arg "-q"))
              (set! quiet true)
              (set! i (+ i 1)))
            ((or (string-eq arg "--fast") (string-eq arg "-f"))
              (set! fast true)
              (set! i (+ i 1)))
            ((or (string-eq arg "--complete") (string-eq arg "-c"))
              (set! complete true)
              (set! i (+ i 1)))
            ((string-eq arg "--validate")
              (set! validate true)
              (set! i (+ i 1)))
            ((string-eq arg "--validate-ns")
              (if (< (+ i 1) argc)
                (do
                  (set! validate-ns-opt (some (argv-to-string argv (+ i 1))))
                  (set! i (+ i 2)))
                (do
                  (println "Error: --validate-ns requires an IRI prefix")
                  (set! help true)
                  (set! i (+ i 1)))))
            ((or (string-eq arg "--background") (string-eq arg "-b"))
              (if (< (+ i 1) argc)
                (do
                  (set! background (some (argv-to-string argv (+ i 1))))
                  (set! i (+ i 2)))
                (do
                  (println "Error: --background requires a file path")
                  (set! help true)
                  (set! i (+ i 1)))))
            ((or (string-eq arg "--emit") (string-eq arg "-o"))
              (if (< (+ i 1) argc)
                (do
                  (set! emit (some (argv-to-string argv (+ i 1))))
                  (set! i (+ i 2)))
                (do
                  (println "Error: --emit requires a file path")
                  (set! help true)
                  (set! i (+ i 1)))))
            (true
              (set! input (some arg))
              (set! i (+ i 1))))))
      (record-new CliArgs
        (input-file input)
        (emit-file emit)
        (background-file background)
        (validate-ns validate-ns-opt)
        (quiet quiet)
        (fast fast)
        (complete complete)
        (validate validate)
        (show-help help)
        (show-version version))))

  (fn print-usage ()
    (@intent "Print CLI usage information")
    (@spec (() -> Unit))
    (println "growl - OWL 2 RL Reasoner")
    (println "")
    (println "Usage: growl [options] <file.ttl>")
    (println "")
    (println "Options:")
    (println "  -h, --help       Show this help message")
    (println "  -q, --quiet      Only print failures and inconsistencies")
    (println "  -o, --emit FILE  Write materialized graph to TTL file")
    (println "  -f, --fast       Skip schema rules and consistency checks")
    (println "  -c, --complete   Enable cls-thing and prp-ap for spec completeness")
    (println "  --validate       Check TBox satisfiability via synthetic instance injection")
    (println "  --validate-ns NS Only validate entities with IRIs starting with NS")
    (println "  -b, --background FILE  Load background ontology (e.g. TLO) for reasoning context")
    (println "  -V, --version    Show version information"))

  ;; ============================================================
  ;; Main
  ;; ============================================================

  (fn main ((argc Int) (argv (Ptr (Ptr U8))))
    (@intent "CLI entry point: parse TTL, run reasoner, report results")
    (@spec ((Int (Ptr (Ptr U8))) -> Int))
    :c-name "main"
    (with-arena 268435456  ;; 256MB for reasoning
      (let ((args (parse-args arena argc argv)))

        ;; Handle version flag
        (if (. args show-version)
          (do
            (c-inline "printf(\"growl %s\\n\", GROWL_VERSION)")
            0)

        ;; Handle help or missing input
        (match (. args input-file)
          ((none)
            (print-usage)
            (if (. args show-help) 0 1))
          ((some input-path)

            (if (. args show-help)
              (do (print-usage) 0)

            ;; Normal operation
            (let ((quiet (. args quiet))
                  (parse-start (slop_now_ms)))

            ;; Parse TTL file
            (match (parse-ttl-file arena input-path)
              ((error e)
                (print "Error: failed to parse ")
                (println input-path)
                (match e
                  ((parse-error pe)
                    (print "  at line ")
                    (print (int-to-string arena (. (. pe position) line)))
                    (print ", column ")
                    (println (int-to-string arena (. (. pe position) column)))
                    (print "  ")
                    (println (. pe message)))
                  ((file-error _)
                    (println "  (file error)")))
                1)

              ((ok g)
                ;; Filter annotation triples and convert to indexed graph
                (let ((annot-set (collect-annotation-properties arena g))
                      (original-size (graph-size g))
                      (ig (graph-to-indexed arena g annot-set))
                      (input-size (indexed-graph-size ig))
                      (filtered-count (- original-size (cast GraphSize input-size)))
                      (parse-elapsed (- (slop_now_ms) parse-start)))

                  (when (not quiet)
                    (print "Parsed ")
                    (print (int-to-string arena input-size))
                    (print " triples from ")
                    (print input-path)
                    (when (> filtered-count 0)
                      (do
                        (print " (filtered ")
                        (print (int-to-string arena filtered-count))
                        (print " annotations)")))
                    (print " (")
                    (print-elapsed arena parse-elapsed)
                    (println ")"))

                  ;; Merge background file if provided
                  (let ((mut combined-ig ig))
                  (match (. args background-file)
                    ((some bg-path)
                      (match (parse-ttl-file arena bg-path)
                        ((error _)
                          (print "Error: failed to parse background file ")
                          (println bg-path)
                          (return 1))
                        ((ok bg-graph)
                          (let ((bg-annot-set (collect-annotation-properties arena bg-graph))
                                (bg-ig (graph-to-indexed arena bg-graph bg-annot-set)))
                            (when (not quiet)
                              (print "Loaded ")
                              (print (int-to-string arena (indexed-graph-size bg-ig)))
                              (print " background triples from ")
                              (println bg-path))
                            ;; Merge background triples into combined graph
                            (let ((bg-triples (. bg-ig triples)))
                              (for-each (t bg-triples)
                                (set! combined-ig (indexed-graph-add arena combined-ig t))))))))
                    ((none) (do)))

                  ;; --validate overrides --fast (needs schema materialization)
                  (let ((validate-mode (. args validate))
                        (effective-fast (and (. args fast) (not validate-mode)))
                        ;; Extract validate-ns from args, default to ""
                        (ns-filter (match (. args validate-ns)
                                     ((some ns) ns)
                                     ((none) ""))))
                  (when (and (. args fast) validate-mode)
                    (println "Warning: --validate overrides --fast (schema materialization required)"))

                  ;; Run reasoner
                  (let ((reason-start (slop_now_ms))
                        (config (record-new ReasonerConfig
                                  (worker-count 4)
                                  (channel-buffer 256)
                                  (max-iterations 1000)
                                  (verbose (not quiet))
                                  (fast effective-fast)
                                  (complete (. args complete))
                                  (validate validate-mode)
                                  (validate-ns ns-filter))))
                  (match (reason-with-config arena combined-ig config)
                    ((reason-success s)
                      (let ((inferred (. s inferred-count))
                            (iters (. s iterations))
                            (reason-elapsed (- (slop_now_ms) reason-start)))

                        (if validate-mode
                          (do
                            (println "[PASS] Validation passed â€” all classes are satisfiable")
                            0)
                          (do
                            (when (not quiet)
                              (print "Reasoning completed: ")
                              (print (int-to-string arena inferred))
                              (print " inferred in ")
                              (print (int-to-string arena iters))
                              (print " iterations (")
                              (print-elapsed arena reason-elapsed)
                              (println ")")
                              (print "Total: ")
                              (print (int-to-string arena (indexed-graph-size (. s graph))))
                              (println " triples"))

                            ;; Always print machine-parseable summary
                            (when quiet
                              (print input-path)
                              (print ": ")
                              (print-elapsed arena parse-elapsed)
                              (print " parse, ")
                              (print-elapsed arena reason-elapsed)
                              (print " reason, ")
                              (print (int-to-string arena input-size))
                              (print " -> ")
                              (print (int-to-string arena (indexed-graph-size (. s graph))))
                              (println " triples"))

                            ;; Emit materialized graph if requested
                            (match (. args emit-file)
                              ((some emit-path)
                                ;; Re-add filtered annotation triples to output
                                (let ((mut out-ig (. s graph)))
                                  (for-each (t (. g triples))
                                    (let ((pred (. t predicate)))
                                      (when (set-has annot-set pred)
                                        (set! out-ig (indexed-graph-add arena out-ig t)))))
                                  (let ((out-graph (indexed-to-graph arena out-ig))
                                        (no-base (Option String) (none))
                                        (config (record-new SerializeConfig
                                                  (prefixes (make-prefix-map arena))
                                                  (base-iri no-base)
                                                  (indent-width 2))))
                                    (match (serialize-ttl-stream arena out-graph config emit-path)
                                      ((ok _)
                                        (when (not quiet)
                                          (print "Wrote materialized graph to ")
                                          (println emit-path))
                                        0)
                                      ((error _)
                                        (print "Error: failed to write ")
                                        (println emit-path)
                                        1)))))
                              ((none) 0))))))

                    ((reason-inconsistent report)
                      (let ((reason-elapsed (- (slop_now_ms) reason-start)))
                        (if validate-mode
                          (do
                            (println "[FAIL] Unsatisfiable class detected")
                            (print "  Reason: ")
                            (println (. report reason))
                            1)
                          (do
                            (when quiet
                              (print input-path)
                              (print ": ")
                              (print-elapsed arena parse-elapsed)
                              (print " parse, ")
                              (print-elapsed arena reason-elapsed)
                              (print " reason, ")
                              (print (int-to-string arena input-size))
                              (println " triples [INCONSISTENT]"))
                            (println "[FAIL] Ontology is inconsistent")
                            (print "  Reason: ")
                            (println (. report reason))
                            1))))))))))))))))))))
