;; ============================================================
;; Growl CLI Integration Tests
;;
;; Tests the full pipeline: parse TTL -> reason -> report/emit
;; Uses fixture TTL files in fixtures/
;; ============================================================

(module test-cli
  (@doc "Integration tests for growl CLI pipeline")

  (import rdf (Term Triple Graph GraphSize make-iri make-blank make-triple make-graph graph-size term-eq
               triple-subject triple-predicate triple-object))
  (import index (IndexedGraph indexed-graph-create indexed-graph-add
                 indexed-graph-match indexed-graph-size indexed-graph-contains))
  (import ttl (PrefixMap PrefixBinding make-prefix-map parse-ttl-file))
  (import serialize-ttl (SerializeConfig serialize-ttl-string serialize-ttl-stream))
  (import vocab (RDF_TYPE RDFS_SUBCLASS_OF OWL_SAME_AS))
  (import growl (reason reason-with-config ReasonerConfig ReasonerResult ReasonerSuccess InconsistencyReport
                 get-inferred-count get-types get-same-as))
  (import strlib (starts-with))

  ;; ============================================================
  ;; Helpers
  ;; ============================================================

  (fn graph-to-indexed ((arena Arena) (g Graph))
    (@intent "Convert Graph to IndexedGraph")
    (@spec ((Arena Graph) -> IndexedGraph))
    (@alloc arena)
    (let ((mut ig (indexed-graph-create arena)))
      (for-each (t (. g triples))
        (set! ig (indexed-graph-add arena ig t)))
      ig))

  (fn indexed-to-graph ((arena Arena) (ig IndexedGraph))
    (@intent "Convert IndexedGraph to Graph")
    (@spec ((Arena IndexedGraph) -> Graph))
    (@alloc arena)
    (record-new Graph
      (triples (. ig triples))
      (size (cast GraphSize (indexed-graph-size ig)))))

  (fn has-type ((arena Arena) (g IndexedGraph) (individual Term) (class Term))
    (@intent "Check if individual has rdf:type class in graph")
    (@spec ((Arena IndexedGraph Term Term) -> Bool))
    (@alloc arena)
    (let ((type-pred (make-iri arena RDF_TYPE))
          (matches (indexed-graph-match arena g (some individual) (some type-pred) (some class))))
      (> (list-len matches) 0)))

  (fn has-same-as ((arena Arena) (g IndexedGraph) (a Term) (b Term))
    (@intent "Check if a owl:sameAs b in graph")
    (@spec ((Arena IndexedGraph Term Term) -> Bool))
    (@alloc arena)
    (let ((same-pred (make-iri arena OWL_SAME_AS))
          (fwd (indexed-graph-match arena g (some a) (some same-pred) (some b)))
          (bwd (indexed-graph-match arena g (some b) (some same-pred) (some a))))
      (or (> (list-len fwd) 0) (> (list-len bwd) 0))))

  (fn print-result ((name String) (passed Bool))
    (@intent "Print test result")
    (@spec ((String Bool) -> Unit))
    (if passed
      (do (print "[PASS] ") (println name))
      (do (print "[FAIL] ") (println name))))

  ;; Blank node remapping for background file merge
  (fn remap-blank-term ((arena Arena) (t Term) (offset I64))
    (@intent "If term is a blank node, return new blank with ID + offset; otherwise return unchanged")
    (@spec ((Arena Term I64) -> Term))
    (@alloc arena)
    (match t
      ((term-blank b) (make-blank arena (+ (. b id) offset)))
      ((term-iri _) t)
      ((term-literal _) t)))

  (fn max-blank-id-in-graph ((ig IndexedGraph))
    (@intent "Find the highest blank node ID across all triples in the graph")
    (@spec ((IndexedGraph) -> I64))
    (@pure)
    (let ((triples (. ig triples))
          (mut max-id 0))
      (for-each (t triples)
        (match (. t subject)
          ((term-blank b) (when (> (. b id) max-id) (set! max-id (. b id))))
          (_ (do)))
        (match (. t object)
          ((term-blank b) (when (> (. b id) max-id) (set! max-id (. b id))))
          (_ (do))))
      max-id))

  ;; ============================================================
  ;; Pipeline helper: parse file -> index -> reason
  ;; ============================================================

  (fn parse-and-reason ((arena Arena) (path String))
    (@intent "Parse TTL file and run reasoner, return result")
    (@spec ((Arena String) -> (Option ReasonerResult)))
    (@alloc arena)
    (match (parse-ttl-file arena path)
      ((error _) (none))
      ((ok g)
        (let ((ig (graph-to-indexed arena g)))
          (some (reason arena ig))))))

  ;; ============================================================
  ;; Test 1: Subclass chain from TTL file
  ;; ============================================================

  (fn test-subclass-chain-file ((arena Arena))
    (@intent "Parse subclass-chain.ttl, verify alice gets inferred types")
    (@spec ((Arena) -> Bool))
    (@alloc arena)
    (match (parse-and-reason arena "fixtures/subclass-chain.ttl")
      ((none)
        (println "  ERROR: failed to parse subclass-chain.ttl")
        false)
      ((some result)
        (match result
          ((reason-success s)
            (let ((alice (make-iri arena "http://example.org/alice"))
                  (person (make-iri arena "http://example.org/Person"))
                  (agent (make-iri arena "http://example.org/Agent"))
                  (g (. s graph)))
              (let ((has-person (has-type arena g alice person))
                    (has-agent (has-type arena g alice agent))
                    (did-infer (> (. s inferred-count) 0)))
                (and has-person (and has-agent did-infer)))))
          ((reason-inconsistent _)
            (println "  ERROR: unexpected inconsistency")
            false)))))

  ;; ============================================================
  ;; Test 2: Equivalent class from TTL file
  ;; ============================================================

  (fn test-equivalent-class-file ((arena Arena))
    (@intent "Parse equivalent-class.ttl, verify bidirectional type inference")
    (@spec ((Arena) -> Bool))
    (@alloc arena)
    (match (parse-and-reason arena "fixtures/equivalent-class.ttl")
      ((none)
        (println "  ERROR: failed to parse equivalent-class.ttl")
        false)
      ((some result)
        (match result
          ((reason-success s)
            (let ((alice (make-iri arena "http://example.org/alice"))
                  (bob (make-iri arena "http://example.org/bob"))
                  (human (make-iri arena "http://example.org/Human"))
                  (person (make-iri arena "http://example.org/Person"))
                  (g (. s graph)))
              ;; alice (typed Human) should get Person
              ;; bob (typed Person) should get Human
              (and (has-type arena g alice person)
                   (has-type arena g bob human))))
          ((reason-inconsistent _)
            (println "  ERROR: unexpected inconsistency")
            false)))))

  ;; ============================================================
  ;; Test 3: Disjoint violation detected
  ;; ============================================================

  (fn test-disjoint-violation-file ((arena Arena))
    (@intent "Parse disjoint-violation.ttl, verify inconsistency detected")
    (@spec ((Arena) -> Bool))
    (@alloc arena)
    (match (parse-and-reason arena "fixtures/disjoint-violation.ttl")
      ((none)
        (println "  ERROR: failed to parse disjoint-violation.ttl")
        false)
      ((some result)
        (match result
          ((reason-success _)
            (println "  ERROR: should have detected inconsistency")
            false)
          ((reason-inconsistent _) true)))))

  ;; ============================================================
  ;; Test 4: sameAs + differentFrom violation
  ;; ============================================================

  (fn test-sameas-differentfrom-file ((arena Arena))
    (@intent "Parse sameas-differentfrom.ttl, verify inconsistency detected")
    (@spec ((Arena) -> Bool))
    (@alloc arena)
    (match (parse-and-reason arena "fixtures/sameas-differentfrom.ttl")
      ((none)
        (println "  ERROR: failed to parse sameas-differentfrom.ttl")
        false)
      ((some result)
        (match result
          ((reason-success _)
            (println "  ERROR: should have detected inconsistency")
            false)
          ((reason-inconsistent _) true)))))

  ;; ============================================================
  ;; Test 5: sameAs transitivity from TTL
  ;; ============================================================

  (fn test-sameas-chain-file ((arena Arena))
    (@intent "Parse sameas-chain.ttl, verify transitive sameAs closure")
    (@spec ((Arena) -> Bool))
    (@alloc arena)
    (match (parse-and-reason arena "fixtures/sameas-chain.ttl")
      ((none)
        (println "  ERROR: failed to parse sameas-chain.ttl")
        false)
      ((some result)
        (match result
          ((reason-success s)
            (let ((alice (make-iri arena "http://example.org/alice"))
                  (charlie (make-iri arena "http://example.org/charlie")))
              (has-same-as arena (. s graph) alice charlie)))
          ((reason-inconsistent _)
            (println "  ERROR: unexpected inconsistency")
            false)))))

  ;; ============================================================
  ;; Test 6: Empty graph passes
  ;; ============================================================

  (fn test-empty-file ((arena Arena))
    (@intent "Parse empty.ttl, verify clean pass (dt-type1 adds datatype declarations)")
    (@spec ((Arena) -> Bool))
    (@alloc arena)
    (match (parse-and-reason arena "fixtures/empty.ttl")
      ((none)
        (println "  ERROR: failed to parse empty.ttl")
        false)
      ((some result)
        (match result
          ((reason-success s)
            (<= (. s inferred-count) 36))
          ((reason-inconsistent _)
            (println "  ERROR: unexpected inconsistency on empty graph")
            false)))))

  ;; ============================================================
  ;; Test 7: BFO ontology passes (real-world)
  ;; ============================================================

  (fn test-bfo-consistent ((arena Arena))
    (@intent "Parse BFO ontology, verify it is consistent")
    (@spec ((Arena) -> Bool))
    (@alloc arena)
    (let ((start-time (now-ms)))
      (println "  BFO: parsing...")
      (match (parse-ttl-file arena "fixtures/bfo-core.ttl")
        ((error _)
          (println "  ERROR: failed to parse bfo-core.ttl")
          false)
        ((ok g)
          (print "  BFO: parsed ")
          (print (int-to-string arena (graph-size g)))
          (println " triples, indexing...")
          (let ((ig (graph-to-indexed arena g)))
            (print "  BFO: indexed ")
            (print (int-to-string arena (indexed-graph-size ig)))
            (println " triples, reasoning...")
            (let ((reason-start (now-ms)))
              (match (reason arena ig)
                ((reason-success s)
                  (let ((end-time (now-ms)))
                    (print "  BFO: ")
                    (print (int-to-string arena (. s inferred-count)))
                    (print " inferred, ")
                    (print (int-to-string arena (. s iterations)))
                    (print " iterations, ")
                    (print (int-to-string arena (- end-time reason-start)))
                    (println "ms reasoning")
                    (print "  BFO: total ")
                    (print (int-to-string arena (- end-time start-time)))
                    (println "ms")
                    true))
                ((reason-inconsistent reports)
                  (print "  ERROR: BFO inconsistent: ")
                  (match (list-get reports 0)
                    ((some report) (println (. report reason)))
                    ((none) (println "(no details)")))
                  false))))))))

  ;; ============================================================
  ;; Test 8: dt-not-type detects invalid literal
  ;; ============================================================

  (fn test-invalid-literal-file ((arena Arena))
    (@intent "Parse invalid-literal.ttl, verify dt-not-type detects inconsistency")
    (@spec ((Arena) -> Bool))
    (@alloc arena)
    (match (parse-and-reason arena "fixtures/invalid-literal.ttl")
      ((none)
        (println "  ERROR: failed to parse invalid-literal.ttl")
        false)
      ((some result)
        (match result
          ((reason-success _)
            (println "  ERROR: should have detected invalid literal")
            false)
          ((reason-inconsistent _) true)))))

  ;; ============================================================
  ;; Test 9: Valid typed literals pass dt-not-type
  ;; ============================================================

  (fn test-valid-literals-file ((arena Arena))
    (@intent "Parse valid-literals.ttl, verify all literals pass validation")
    (@spec ((Arena) -> Bool))
    (@alloc arena)
    (match (parse-and-reason arena "fixtures/valid-literals.ttl")
      ((none)
        (println "  ERROR: failed to parse valid-literals.ttl")
        false)
      ((some result)
        (match result
          ((reason-success _) true)
          ((reason-inconsistent reports)
            (print "  ERROR: unexpected inconsistency: ")
            (match (list-get reports 0)
              ((some report) (println (. report reason)))
              ((none) (println "(no details)")))
            false)))))

  ;; ============================================================
  ;; Test 10: Round-trip emit (parse -> reason -> serialize -> parse)
  ;; ============================================================

  (fn test-emit-roundtrip ((arena Arena))
    (@intent "Parse TTL, reason, emit to file, re-parse and verify size")
    (@spec ((Arena) -> Bool))
    (@alloc arena)
    (match (parse-and-reason arena "fixtures/subclass-chain.ttl")
      ((none)
        (println "  ERROR: failed to parse for roundtrip")
        false)
      ((some result)
        (match result
          ((reason-success s)
            (let ((out-graph (indexed-to-graph arena (. s graph)))
                  (no-base (Option String) (none))
                  (config (record-new SerializeConfig
                            (prefixes (make-prefix-map arena))
                            (base-iri no-base)
                            (indent-width 2)))
                  (emit-path "fixtures/roundtrip-out.ttl"))
              ;; Write materialized graph
              (match (serialize-ttl-stream arena out-graph config emit-path)
                ((error _)
                  (println "  ERROR: failed to write roundtrip file")
                  false)
                ((ok _)
                  ;; Re-parse the emitted file
                  (match (parse-ttl-file arena emit-path)
                    ((error _)
                      (println "  ERROR: failed to re-parse emitted file")
                      false)
                    ((ok g2)
                      ;; Emitted graph should have at least as many triples as input
                      (let ((original-size (indexed-graph-size (. s graph)))
                            (reparsed-size (graph-size g2)))
                        (do
                          (print "  Roundtrip: emitted ")
                          (print (int-to-string arena original-size))
                          (print " triples, re-parsed ")
                          (println (int-to-string arena reparsed-size))
                          ;; Reparsed should have same or more triples
                          ;; (serializer may produce slightly different count due to grouping)
                          (>= reparsed-size 3)))))))))
          ((reason-inconsistent _)
            (println "  ERROR: unexpected inconsistency in roundtrip")
            false)))))

  ;; ============================================================
  ;; Test 9: Nonexistent file fails gracefully
  ;; ============================================================

  (fn test-missing-file ((arena Arena))
    (@intent "Verify that a missing file returns none (parse failure)")
    (@spec ((Arena) -> Bool))
    (@alloc arena)
    (match (parse-and-reason arena "fixtures/does-not-exist.ttl")
      ((none) true)
      ((some _)
        (println "  ERROR: should have failed on missing file")
        false)))

  ;; ============================================================
  ;; Test 12: --validate detects unsatisfiable TBox class
  ;; ============================================================

  (fn test-validate-unsat ((arena Arena))
    (@intent "Parse TBox-only ontology with unsatisfiable class, verify --validate catches it")
    (@spec ((Arena) -> Bool))
    (@alloc arena)
    (match (parse-ttl-file arena "fixtures/validate-unsat.ttl")
      ((error _)
        (println "  ERROR: failed to parse validate-unsat.ttl")
        false)
      ((ok g)
        (let ((ig (graph-to-indexed arena g))
              (config (record-new ReasonerConfig
                        (worker-count 4)
                        (channel-buffer 256)
                        (max-iterations 1000)
                        (verbose false)
                        (fast false)
                        (complete false)
                        (validate true)
                        (validate-ns ""))))
          (match (reason-with-config arena ig config)
            ((reason-inconsistent _) true)
            ((reason-success _)
              (println "  ERROR: should have detected unsatisfiable class")
              false))))))

  ;; ============================================================
  ;; Test 13: --validate passes clean TBox
  ;; ============================================================

  (fn test-validate-clean ((arena Arena))
    (@intent "Parse TBox-only ontology with no issues, verify --validate passes")
    (@spec ((Arena) -> Bool))
    (@alloc arena)
    (match (parse-ttl-file arena "fixtures/validate-clean.ttl")
      ((error _)
        (println "  ERROR: failed to parse validate-clean.ttl")
        false)
      ((ok g)
        (let ((ig (graph-to-indexed arena g))
              (config (record-new ReasonerConfig
                        (worker-count 4)
                        (channel-buffer 256)
                        (max-iterations 1000)
                        (verbose false)
                        (fast false)
                        (complete false)
                        (validate true)
                        (validate-ns ""))))
          (match (reason-with-config arena ig config)
            ((reason-success _) true)
            ((reason-inconsistent reports)
              (print "  ERROR: unexpected inconsistency: ")
              (match (list-get reports 0)
                ((some report) (println (. report reason)))
                ((none) (println "(no details)")))
              false))))))

  ;; ============================================================
  ;; Test 14: Same unsatisfiable TBox passes WITHOUT --validate
  ;; ============================================================

  (fn test-no-validate-unsat-passes ((arena Arena))
    (@intent "Same TBox-only ontology without --validate should pass (no instances)")
    (@spec ((Arena) -> Bool))
    (@alloc arena)
    (match (parse-and-reason arena "fixtures/validate-unsat.ttl")
      ((none)
        (println "  ERROR: failed to parse validate-unsat.ttl")
        false)
      ((some result)
        (match result
          ((reason-success _) true)
          ((reason-inconsistent _)
            (println "  ERROR: should pass without --validate (TBox only)")
            false)))))

  ;; ============================================================
  ;; Test 15: --validate detects unsatisfiable property usage
  ;; ============================================================

  (fn test-validate-unsat-prop ((arena Arena))
    (@intent "Parse property with both Symmetric and Asymmetric, verify --validate catches it")
    (@spec ((Arena) -> Bool))
    (@alloc arena)
    (match (parse-ttl-file arena "fixtures/validate-unsat-prop.ttl")
      ((error _)
        (println "  ERROR: failed to parse validate-unsat-prop.ttl")
        false)
      ((ok g)
        (let ((ig (graph-to-indexed arena g))
              (config (record-new ReasonerConfig
                        (worker-count 4)
                        (channel-buffer 256)
                        (max-iterations 1000)
                        (verbose false)
                        (fast false)
                        (complete false)
                        (validate true)
                        (validate-ns ""))))
          (match (reason-with-config arena ig config)
            ((reason-inconsistent _) true)
            ((reason-success _)
              (println "  ERROR: should have detected unsatisfiable property")
              false))))))

  ;; ============================================================
  ;; Test 16: --validate domain-mediated reports class, not property
  ;; ============================================================

  (fn test-validate-domain-reports-class ((arena Arena))
    (@intent "Property with unsatisfiable domain class should report class, not property")
    (@spec ((Arena) -> Bool))
    (@alloc arena)
    (match (parse-ttl-file arena "fixtures/validate-domain-unsat.ttl")
      ((error _)
        (println "  ERROR: failed to parse validate-domain-unsat.ttl")
        false)
      ((ok g)
        (let ((ig (graph-to-indexed arena g))
              (config (record-new ReasonerConfig
                        (worker-count 4)
                        (channel-buffer 256)
                        (max-iterations 1000)
                        (verbose false)
                        (fast false)
                        (complete false)
                        (validate true)
                        (validate-ns ""))))
          (match (reason-with-config arena ig config)
            ((reason-inconsistent reports)
              ;; Check that enriched reason says "Unsatisfiable class:" not "Unsatisfiable property usage:"
              (match (list-get reports 0)
                ((some report) (starts-with (. report reason) "Unsatisfiable class:"))
                ((none) false)))
            ((reason-success _)
              (println "  ERROR: should have detected inconsistency")
              false))))))

  ;; ============================================================
  ;; Test 17: --validate-ns scopes to domain namespace only
  ;; ============================================================

  (fn test-validate-ns-scoping ((arena Arena))
    (@intent "Combined ontology with TLO + domain: validate-ns limits to domain entities only")
    (@spec ((Arena) -> Bool))
    (@alloc arena)
    ;; validate-bg-domain.ttl has TLO classes (tlo:Animal, tlo:Plant) and domain class (ex:Bad)
    ;; ex:Bad subClassOf both disjoint TLO classes â†’ unsatisfiable
    ;; With validate-ns=http://example.org/, only ex:Bad gets a synthetic instance
    (match (parse-ttl-file arena "fixtures/validate-bg-domain.ttl")
      ((error _)
        (println "  ERROR: failed to parse validate-bg-domain.ttl")
        false)
      ((ok g)
        (let ((ig (graph-to-indexed arena g))
              (config (record-new ReasonerConfig
                        (worker-count 4)
                        (channel-buffer 256)
                        (max-iterations 1000)
                        (verbose false)
                        (fast false)
                        (complete false)
                        (validate true)
                        (validate-ns "http://example.org/"))))
          (match (reason-with-config arena ig config)
            ((reason-inconsistent reports)
              ;; Should detect ex:Bad as unsatisfiable
              (match (list-get reports 0)
                ((some report) (starts-with (. report reason) "Unsatisfiable class:"))
                ((none) false)))
            ((reason-success _)
              (println "  ERROR: should have detected unsatisfiable ex:Bad")
              false))))))

  ;; ============================================================
  ;; Test 18: --validate-ns filters out TLO entities from validation
  ;; ============================================================

  (fn test-validate-ns-filters-tlo ((arena Arena))
    (@intent "TLO-only entities are not validated when validate-ns scopes to domain prefix")
    (@spec ((Arena) -> Bool))
    (@alloc arena)
    ;; validate-bg-tlo.ttl has only TLO classes (tlo:Animal, tlo:Plant, disjoint)
    ;; With validate-ns=http://example.org/, NO synthetic instances are created
    ;; â†’ should pass even though TLO has disjoint classes
    (match (parse-ttl-file arena "fixtures/validate-bg-tlo.ttl")
      ((error _)
        (println "  ERROR: failed to parse validate-bg-tlo.ttl")
        false)
      ((ok g)
        (let ((ig (graph-to-indexed arena g))
              (config (record-new ReasonerConfig
                        (worker-count 4)
                        (channel-buffer 256)
                        (max-iterations 1000)
                        (verbose false)
                        (fast false)
                        (complete false)
                        (validate true)
                        (validate-ns "http://example.org/"))))
          (match (reason-with-config arena ig config)
            ((reason-success _) true)
            ((reason-inconsistent reports)
              (print "  ERROR: unexpected inconsistency: ")
              (match (list-get reports 0)
                ((some report) (println (. report reason)))
                ((none) (println "(no details)")))
              false))))))

  ;; ============================================================
  ;; Test 19: --background merge pattern
  ;; ============================================================

  (fn test-background-merge ((arena Arena))
    (@intent "Parse TLO + domain-only files, merge, verify --validate detects unsatisfiable class")
    (@spec ((Arena) -> Bool))
    (@alloc arena)
    ;; Parse background TLO file
    (match (parse-ttl-file arena "fixtures/validate-bg-tlo.ttl")
      ((error _)
        (println "  ERROR: failed to parse validate-bg-tlo.ttl")
        false)
      ((ok bg-graph)
        ;; Parse domain-only file
        (match (parse-ttl-file arena "fixtures/validate-domain-only.ttl")
          ((error _)
            (println "  ERROR: failed to parse validate-domain-only.ttl")
            false)
          ((ok domain-graph)
            ;; Convert domain to indexed graph, remap bg blank nodes to avoid collision
            (let ((mut ig (graph-to-indexed arena domain-graph))
                  (bg-blank-offset (+ (max-blank-id-in-graph ig) 1)))
              (for-each (t (. bg-graph triples))
                (let ((rs (remap-blank-term arena (. t subject) bg-blank-offset))
                      (rp (. t predicate))
                      (ro (remap-blank-term arena (. t object) bg-blank-offset))
                      (remapped (make-triple arena rs rp ro)))
                  (set! ig (indexed-graph-add arena ig remapped))))
              ;; Reason with validate + validate-ns
              (let ((config (record-new ReasonerConfig
                              (worker-count 4)
                              (channel-buffer 256)
                              (max-iterations 1000)
                              (verbose false)
                              (fast false)
                              (complete false)
                              (validate true)
                              (validate-ns "http://example.org/"))))
                (match (reason-with-config arena ig config)
                  ((reason-inconsistent reports)
                    ;; Should detect ex:Bad as unsatisfiable
                    (match (list-get reports 0)
                      ((some report) (starts-with (. report reason) "Unsatisfiable class:"))
                      ((none) false)))
                  ((reason-success _)
                    (println "  ERROR: should have detected unsatisfiable ex:Bad via background merge")
                    false)))))))))

  ;; ============================================================
  ;; Test 20: Multiple unsatisfiable classes reported in one pass
  ;; ============================================================

  (fn test-validate-multiple-unsat ((arena Arena))
    (@intent "Validate mode finds all unsatisfiable classes, not just the first")
    (@spec ((Arena) -> Bool))
    (@alloc arena)
    (match (parse-ttl-file arena "fixtures/validate-multi-unsat.ttl")
      ((error _)
        (println "  ERROR: failed to parse validate-multi-unsat.ttl")
        false)
      ((ok g)
        (let ((ig (graph-to-indexed arena g))
              (config (record-new ReasonerConfig
                        (worker-count 4)
                        (channel-buffer 256)
                        (max-iterations 1000)
                        (verbose false)
                        (fast false)
                        (complete false)
                        (validate true)
                        (validate-ns ""))))
          (match (reason-with-config arena ig config)
            ((reason-inconsistent reports)
              ;; Should find exactly 2 unsatisfiable classes (Triffid and Steam)
              (let ((count (list-len reports)))
                (if (== count 2)
                  (do
                    ;; Both should be "Unsatisfiable class:"
                    (let ((mut all-class true))
                      (for-each (r reports)
                        (when (not (starts-with (. r reason) "Unsatisfiable class:"))
                          (do
                            (print "  ERROR: unexpected report: ")
                            (println (. r reason))
                            (set! all-class false))))
                      all-class))
                  (do
                    (print "  ERROR: expected 2 reports, got ")
                    (println (int-to-string arena count))
                    (for-each (r reports)
                      (print "    ")
                      (println (. r reason)))
                    false))))
            ((reason-success _)
              (println "  ERROR: should have detected unsatisfiable classes")
              false))))))

  ;; ============================================================
  ;; Main Test Runner
  ;; ============================================================

  (fn main ()
    (@intent "Run all CLI integration tests")
    (@spec (() -> Int))
    :c-name "main"
    (with-arena 536870912  ;; 512MB for test harness
      (let ((mut passed 0)
            (mut failed 0))

        (println "========================================")
        (println "Growl CLI Integration Tests")
        (println "========================================")
        (println "")

        ;; Real-world ontology test (requires 8GB arena_cap)
        (let ((r (test-bfo-consistent arena)))
          (print-result "BFO ontology consistent" r)
          (if r (set! passed (+ passed 1)) (set! failed (+ failed 1))))

        ;; Consistent ontologies
        (let ((r (test-subclass-chain-file arena)))
          (print-result "subclass chain from TTL" r)
          (if r (set! passed (+ passed 1)) (set! failed (+ failed 1))))

        (let ((r (test-equivalent-class-file arena)))
          (print-result "equivalent class from TTL" r)
          (if r (set! passed (+ passed 1)) (set! failed (+ failed 1))))

        (let ((r (test-sameas-chain-file arena)))
          (print-result "sameAs transitivity from TTL" r)
          (if r (set! passed (+ passed 1)) (set! failed (+ failed 1))))

        (let ((r (test-empty-file arena)))
          (print-result "empty graph from TTL" r)
          (if r (set! passed (+ passed 1)) (set! failed (+ failed 1))))

        ;; Inconsistent ontologies
        (let ((r (test-disjoint-violation-file arena)))
          (print-result "disjoint violation detected" r)
          (if r (set! passed (+ passed 1)) (set! failed (+ failed 1))))

        (let ((r (test-sameas-differentfrom-file arena)))
          (print-result "sameAs/differentFrom violation detected" r)
          (if r (set! passed (+ passed 1)) (set! failed (+ failed 1))))

        ;; Datatype rules
        (let ((r (test-invalid-literal-file arena)))
          (print-result "dt-not-type: invalid literal detected" r)
          (if r (set! passed (+ passed 1)) (set! failed (+ failed 1))))

        (let ((r (test-valid-literals-file arena)))
          (print-result "dt-not-type: valid literals pass" r)
          (if r (set! passed (+ passed 1)) (set! failed (+ failed 1))))

        ;; Emit roundtrip
        (let ((r (test-emit-roundtrip arena)))
          (print-result "emit roundtrip (serialize + re-parse)" r)
          (if r (set! passed (+ passed 1)) (set! failed (+ failed 1))))

        ;; Validate mode
        (let ((r (test-validate-unsat arena)))
          (print-result "validate: unsatisfiable class detected" r)
          (if r (set! passed (+ passed 1)) (set! failed (+ failed 1))))

        (let ((r (test-validate-clean arena)))
          (print-result "validate: clean TBox passes" r)
          (if r (set! passed (+ passed 1)) (set! failed (+ failed 1))))

        (let ((r (test-no-validate-unsat-passes arena)))
          (print-result "validate: unsat TBox passes without --validate" r)
          (if r (set! passed (+ passed 1)) (set! failed (+ failed 1))))

        (let ((r (test-validate-unsat-prop arena)))
          (print-result "validate: unsatisfiable property detected" r)
          (if r (set! passed (+ passed 1)) (set! failed (+ failed 1))))

        (let ((r (test-validate-domain-reports-class arena)))
          (print-result "validate: domain-mediated reports class" r)
          (if r (set! passed (+ passed 1)) (set! failed (+ failed 1))))

        ;; Validate namespace scoping
        (let ((r (test-validate-ns-scoping arena)))
          (print-result "validate-ns: scoped to domain namespace" r)
          (if r (set! passed (+ passed 1)) (set! failed (+ failed 1))))

        (let ((r (test-validate-ns-filters-tlo arena)))
          (print-result "validate-ns: TLO entities filtered out" r)
          (if r (set! passed (+ passed 1)) (set! failed (+ failed 1))))

        ;; Background merge
        (let ((r (test-background-merge arena)))
          (print-result "background merge: detects unsatisfiable class" r)
          (if r (set! passed (+ passed 1)) (set! failed (+ failed 1))))

        ;; Multi-unsat validation
        (let ((r (test-validate-multiple-unsat arena)))
          (print-result "validate: multiple unsatisfiable classes" r)
          (if r (set! passed (+ passed 1)) (set! failed (+ failed 1))))

        ;; Error handling
        (let ((r (test-missing-file arena)))
          (print-result "missing file handled gracefully" r)
          (if r (set! passed (+ passed 1)) (set! failed (+ failed 1))))

        ;; Summary
        (println "")
        (println "========================================")
        (print "Passed: ")
        (println (int-to-string arena passed))
        (print "Failed: ")
        (println (int-to-string arena failed))
        (println "========================================")

        (if (== failed 0) 0 1)))))
