;; ============================================================
;; Growl Engine: Parallel Fixpoint Rule Evaluation
;;
;; Implements fork-join parallel semi-naive evaluation.
;; 12 semantic sub-workers split across 5 rule groups
;; (scm, cax, prp, eq, cls), each with its own thread
;; and arena; results merge on the coordinator thread.
;; ============================================================

(module engine
  (@doc "Parallel fixpoint rule engine with fork-join pattern")

  (import rdf (Term Triple triple-eq))
  (import index (IndexedGraph indexed-graph-add indexed-graph-contains indexed-graph-size indexed-graph-match indexed-graph-for-each))
  (import thread (chan-buffered send recv spawn join))
  (import types (Delta ReasonerConfig EngineState ReasonerResult ReasonerSuccess
                 InconsistencyReport make-delta delta-add delta-merge delta-is-empty))
  (import cax (apply-cax-rules cax-sco cax-eqc1 cax-eqc2 cax-dw cax-adc))
  (import scm (apply-scm-rules scm-cls scm-sco scm-eqc1 scm-eqc2
               scm-op scm-dp scm-spo scm-eqp1 scm-eqp2
               scm-dom1 scm-dom2 scm-rng1 scm-rng2))
  (import prp (apply-prp-rules prp-dom prp-rng prp-fp prp-ifp prp-symp prp-trp
               prp-asyp prp-irp prp-pdw prp-spo1 prp-eqp1 prp-eqp2 prp-inv1 prp-inv2))
  (import eq  (apply-eq-rules eq-sym eq-trans eq-rep-s eq-rep-p eq-rep-o
               eq-diff1 eq-diff2 eq-diff3))
  (import cls (apply-cls-rules cls-nothing2 cls-int1 cls-int2 cls-uni cls-com
               cls-svf1 cls-svf2 cls-avf cls-hv1 cls-hv2 cls-maxc1 cls-maxc2 cls-oo))

  (export
    engine-run
    engine-run-iteration
    apply-all-rules
    merge-into-graph
    print-ms)

  ;; ============================================================
  ;; Types
  ;; ============================================================

  ;; Message from worker to coordinator
  (type WorkerMessage (union
    (msg-delta Delta)
    (msg-inconsistent InconsistencyReport)
    (msg-done Unit)))

  ;; ============================================================
  ;; Timing Helpers
  ;; ============================================================

  (fn print-ms ((arena Arena) (ms I64))
    (@intent "Print a millisecond duration like '12ms'")
    (@spec ((Arena I64) -> Unit))
    (print (int-to-string arena ms))
    (print "ms"))

  ;; ============================================================
  ;; Main Engine Loop
  ;; ============================================================

  (fn engine-run ((arena Arena) (config ReasonerConfig) (initial IndexedGraph))
    (@intent "Run parallel rules to fixpoint, return final graph or inconsistency")
    (@spec ((Arena ReasonerConfig IndexedGraph) -> ReasonerResult))
    (@alloc arena)
    (@pre {(. config worker-count) >= 1})
    (@pre {(. config max-iterations) >= 1})
    (@pre {(indexed-graph-size initial) >= 0})
    (@post (match $result
             ((reason-success s) {(. s iterations) <= (. config max-iterations)})
             ((reason-inconsistent _) true)))
    (let ((initial-size (indexed-graph-size initial))
          (mut state (record-new EngineState
                       (graph initial)
                       (delta (make-initial-delta arena initial))
                       (iteration 0)
                       (config config)))
          (mut done false)
          (mut inconsistency (Option InconsistencyReport) (none)))

      ;; Main fixpoint loop
      (while (and (not done) (< (. state iteration) (. config max-iterations)))
        (@loop-invariant {(. state iteration) <= (. config max-iterations)})
        (when (. config verbose)
          (do
            (print "[iter ")
            (print (int-to-string arena (. state iteration)))
            (print "] graph=")
            (print (int-to-string arena (indexed-graph-size (. state graph))))
            (println "")))
        (match (engine-run-iteration arena state)
          ((ok new-state)
            (if (delta-is-empty (. new-state delta))
              (set! done true)
              (set! state new-state)))
          ((error report)
            (do
              (set! done true)
              (set! inconsistency (some report))))))

      ;; Return result
      (match inconsistency
        ((some report) (union-new ReasonerResult reason-inconsistent report))
        ((none)
          (union-new ReasonerResult reason-success (record-new ReasonerSuccess
            (graph (. state graph))
            (inferred-count (- (indexed-graph-size (. state graph)) initial-size))
            (iterations (. state iteration))))))))

  (fn make-initial-delta ((arena Arena) (g IndexedGraph))
    (@intent "Create initial delta containing all triples in graph")
    (@spec ((Arena IndexedGraph) -> Delta))
    (@alloc arena)
    (@post {(. $result iteration) == 0})
    (let ((mut d (make-delta arena 0)))
      ;; In first iteration, all triples are "new"
      (indexed-graph-for-each g (none) (none) (none)
        (fn ((t Triple))
          (set! d (delta-add arena d t))))
      d))

  ;; ============================================================
  ;; Single Iteration
  ;; ============================================================

  (fn engine-run-iteration ((arena Arena) (state EngineState))
    (@intent "Run one iteration of rule application across all workers")
    (@spec ((Arena EngineState) -> (Result EngineState InconsistencyReport)))
    (@alloc arena)
    (@pre {(. state iteration) >= 0})
    (@post (match $result
             ((ok new-state) {(. new-state iteration) == (+ (. state iteration) 1)})
             ((error _) true)))
    ;; Apply all rules to get new inferred triples
    (match (apply-all-rules arena (. state graph) (. state delta) (. state config))
      ((ok new-delta)
        ;; Merge new triples into graph and update state
        (ok (record-new EngineState
              (graph (merge-into-graph arena (. state graph) new-delta))
              (delta new-delta)
              (iteration (+ (. state iteration) 1))
              (config (. state config)))))
      ((error report)
        (error report))))

  ;; ============================================================
  ;; Rule Application: Dispatch
  ;; ============================================================

  (fn apply-all-rules ((arena Arena) (g IndexedGraph) (delta Delta) (config ReasonerConfig))
    (@intent "Apply all OWL 2 RL rules, dispatching to sequential or parallel path")
    (@spec ((Arena IndexedGraph Delta ReasonerConfig) -> (Result Delta InconsistencyReport)))
    (@alloc arena)
    (@pre {(indexed-graph-size g) >= 0})
    (@post (match $result
             ((ok d) {(. d iteration) == (+ (. delta iteration) 1)})
             ((error _) true)))
    ;; Iteration 0 always runs sequentially to pre-intern all vocabulary
    ;; strings in the global intern pool before concurrent access.
    ;; Single-worker config also uses sequential path.
    (if (or (<= (. config worker-count) 1) (== (. delta iteration) 0))
      (apply-all-rules-sequential arena g delta config)
      (apply-all-rules-parallel arena g delta config)))

  ;; ============================================================
  ;; Rule Application: Sequential Path
  ;; ============================================================

  (fn apply-all-rules-sequential ((arena Arena) (g IndexedGraph) (delta Delta) (config ReasonerConfig))
    (@intent "Apply all OWL 2 RL rules sequentially, return combined delta")
    (@spec ((Arena IndexedGraph Delta ReasonerConfig) -> (Result Delta InconsistencyReport)))
    (@alloc arena)
    (@pre {(indexed-graph-size g) >= 0})
    (@post (match $result
             ((ok d) {(. d iteration) == (+ (. delta iteration) 1)})
             ((error _) true)))
    (let ((next-iter (+ (. delta iteration) 1))
          (mut combined (make-delta arena next-iter))
          (verbose (. config verbose)))

      ;; Apply each rule group sequentially with optional timing

      ;; Schema rules first (often create subclass hierarchies)
      (let ((t0 (now-ms)))
        (match (apply-scm-rules arena g delta)
          ((ok scm-delta)
            (do
              (when verbose
                (do (print "  scm: ") (print-ms arena (- (now-ms) t0)) (println "")))
              (set! combined (delta-merge arena combined scm-delta))))
          ((error report) (return (error report)))))

      ;; Class axiom rules (subclass propagation)
      (let ((t0 (now-ms)))
        (match (apply-cax-rules arena g delta)
          ((ok cax-delta)
            (do
              (when verbose
                (do (print "  cax: ") (print-ms arena (- (now-ms) t0)) (println "")))
              (set! combined (delta-merge arena combined cax-delta))))
          ((error report) (return (error report)))))

      ;; Property rules
      (let ((t0 (now-ms)))
        (match (apply-prp-rules arena g delta)
          ((ok prp-delta)
            (do
              (when verbose
                (do (print "  prp: ") (print-ms arena (- (now-ms) t0)) (println "")))
              (set! combined (delta-merge arena combined prp-delta))))
          ((error report) (return (error report)))))

      ;; Equality rules
      (let ((t0 (now-ms)))
        (match (apply-eq-rules arena g delta)
          ((ok eq-delta)
            (do
              (when verbose
                (do (print "  eq:  ") (print-ms arena (- (now-ms) t0)) (println "")))
              (set! combined (delta-merge arena combined eq-delta))))
          ((error report) (return (error report)))))

      ;; Class expression rules
      (let ((t0 (now-ms)))
        (match (apply-cls-rules arena g delta)
          ((ok cls-delta)
            (do
              (when verbose
                (do (print "  cls: ") (print-ms arena (- (now-ms) t0)) (println "")))
              (set! combined (delta-merge arena combined cls-delta))))
          ((error report) (return (error report)))))

      ;; Each rule already checks (indexed-graph-contains g inferred) before adding,
      ;; and delta-add deduplicates across rules via (set-has seen t).
      (ok combined)))

  ;; ============================================================
  ;; Rule Application: Parallel Path (Fork-Join)
  ;; ============================================================

  (fn apply-all-rules-parallel ((arena Arena) (g IndexedGraph) (delta Delta) (config ReasonerConfig))
    (@intent "Apply all OWL 2 RL rules in parallel using fork-join, 12 semantic sub-workers")
    (@spec ((Arena IndexedGraph Delta ReasonerConfig) -> (Result Delta InconsistencyReport)))
    (@alloc arena)
    (@pre {(indexed-graph-size g) >= 0})
    (@pre {(. config worker-count) > 1})
    (@post (match $result
             ((ok d) {(. d iteration) == (+ (. delta iteration) 1)})
             ((error _) true)))
    (let ((next-iter (+ (. delta iteration) 1))
          (result-chan (chan-buffered WorkerMessage arena (. config channel-buffer)))
          ;; Allocate coordinator-owned per-worker arenas so data survives until collect
          ;; 12 arenas: 3 scm + 2 cax + 3 prp + 2 eq + 2 cls
          (arena-scm-class  (arena-new 1048576))
          (arena-scm-prop   (arena-new 1048576))
          (arena-scm-domrng (arena-new 1048576))
          (arena-cax-infer  (arena-new 1048576))
          (arena-cax-check  (arena-new 1048576))
          (arena-prp-char   (arena-new 1048576))
          (arena-prp-chain  (arena-new 1048576))
          (arena-prp-check  (arena-new 1048576))
          (arena-eq-infer   (arena-new 1048576))
          (arena-eq-check   (arena-new 1048576))
          (arena-cls-set    (arena-new 1048576))
          (arena-cls-ind    (arena-new 1048576)))

      ;; Spawn 12 sub-workers, each handling a semantic subset of rules
      (let ((workers (spawn-rule-workers arena g delta result-chan
                                         arena-scm-class arena-scm-prop arena-scm-domrng
                                         arena-cax-infer arena-cax-check
                                         arena-prp-char arena-prp-chain arena-prp-check
                                         arena-eq-infer arena-eq-check
                                         arena-cls-set arena-cls-ind
                                         (. config verbose))))

        ;; Collect results from all workers
        (let ((result (collect-worker-results arena result-chan workers next-iter)))

          ;; Free worker arenas now that results have been merged into coordinator arena
          (arena-free arena-scm-class)
          (arena-free arena-scm-prop)
          (arena-free arena-scm-domrng)
          (arena-free arena-cax-infer)
          (arena-free arena-cax-check)
          (arena-free arena-prp-char)
          (arena-free arena-prp-chain)
          (arena-free arena-prp-check)
          (arena-free arena-eq-infer)
          (arena-free arena-eq-check)
          (arena-free arena-cls-set)
          (arena-free arena-cls-ind)

          result))))

  ;; ============================================================
  ;; Graph Merging
  ;; ============================================================

  (fn merge-into-graph ((arena Arena) (g IndexedGraph) (d Delta))
    (@intent "Add all triples from delta into graph")
    (@spec ((Arena IndexedGraph Delta) -> IndexedGraph))
    (@alloc arena)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(indexed-graph-size $result) >= (indexed-graph-size g)})
    (@post {(indexed-graph-size $result) <= (+ (indexed-graph-size g) (list-len (. d triples)))})
    (let ((mut result g))
      (for-each (t (. d triples))
        (set! result (indexed-graph-add arena result t)))
      result))

  ;; ============================================================
  ;; Parallel Worker Management
  ;; ============================================================

  (fn spawn-rule-workers ((arena Arena) (g IndexedGraph) (delta Delta)
                          (result-chan (Ptr (Chan WorkerMessage)))
                          (arena-scm-class Arena) (arena-scm-prop Arena) (arena-scm-domrng Arena)
                          (arena-cax-infer Arena) (arena-cax-check Arena)
                          (arena-prp-char Arena) (arena-prp-chain Arena) (arena-prp-check Arena)
                          (arena-eq-infer Arena) (arena-eq-check Arena)
                          (arena-cls-set Arena) (arena-cls-ind Arena)
                          (verbose Bool))
    (@intent "Spawn 12 sub-worker threads, each handling a semantic subset of rules")
    (@spec ((Arena IndexedGraph Delta (Ptr (Chan WorkerMessage))
             Arena Arena Arena Arena Arena Arena Arena Arena Arena Arena Arena Arena Bool)
            -> (List (Ptr (Thread Unit)))))
    (@alloc arena)
    (let ((mut workers (list-new arena (Ptr (Thread Unit))))
          (next-iter (+ (. delta iteration) 1)))

      ;; ---- SCM sub-workers (3) ----

      ;; scm-class: scm-cls, scm-sco, scm-eqc1, scm-eqc2
      (list-push workers
        (spawn arena (fn ()
          (let ((t0 (now-ms))
                (mut result (make-delta arena-scm-class next-iter)))
            (for-each (t (scm-cls arena-scm-class g delta))
              (set! result (delta-add arena-scm-class result t)))
            (for-each (t (scm-sco arena-scm-class g delta))
              (set! result (delta-add arena-scm-class result t)))
            (for-each (t (scm-eqc1 arena-scm-class g delta))
              (set! result (delta-add arena-scm-class result t)))
            (for-each (t (scm-eqc2 arena-scm-class g delta))
              (set! result (delta-add arena-scm-class result t)))
            (when verbose
              (do (print "  scm-class: ") (print-ms arena-scm-class (- (now-ms) t0)) (println "")))
            (send result-chan (union-new WorkerMessage msg-delta result))
            (send result-chan (union-new WorkerMessage msg-done unit))))))

      ;; scm-prop: scm-op, scm-dp, scm-spo, scm-eqp1, scm-eqp2
      (list-push workers
        (spawn arena (fn ()
          (let ((t0 (now-ms))
                (mut result (make-delta arena-scm-prop next-iter)))
            (for-each (t (scm-op arena-scm-prop g delta))
              (set! result (delta-add arena-scm-prop result t)))
            (for-each (t (scm-dp arena-scm-prop g delta))
              (set! result (delta-add arena-scm-prop result t)))
            (for-each (t (scm-spo arena-scm-prop g delta))
              (set! result (delta-add arena-scm-prop result t)))
            (for-each (t (scm-eqp1 arena-scm-prop g delta))
              (set! result (delta-add arena-scm-prop result t)))
            (for-each (t (scm-eqp2 arena-scm-prop g delta))
              (set! result (delta-add arena-scm-prop result t)))
            (when verbose
              (do (print "  scm-prop: ") (print-ms arena-scm-prop (- (now-ms) t0)) (println "")))
            (send result-chan (union-new WorkerMessage msg-delta result))
            (send result-chan (union-new WorkerMessage msg-done unit))))))

      ;; scm-domrng: scm-dom1, scm-dom2, scm-rng1, scm-rng2
      (list-push workers
        (spawn arena (fn ()
          (let ((t0 (now-ms))
                (mut result (make-delta arena-scm-domrng next-iter)))
            (for-each (t (scm-dom1 arena-scm-domrng g delta))
              (set! result (delta-add arena-scm-domrng result t)))
            (for-each (t (scm-dom2 arena-scm-domrng g delta))
              (set! result (delta-add arena-scm-domrng result t)))
            (for-each (t (scm-rng1 arena-scm-domrng g delta))
              (set! result (delta-add arena-scm-domrng result t)))
            (for-each (t (scm-rng2 arena-scm-domrng g delta))
              (set! result (delta-add arena-scm-domrng result t)))
            (when verbose
              (do (print "  scm-domrng: ") (print-ms arena-scm-domrng (- (now-ms) t0)) (println "")))
            (send result-chan (union-new WorkerMessage msg-delta result))
            (send result-chan (union-new WorkerMessage msg-done unit))))))

      ;; ---- CAX sub-workers (2) ----

      ;; cax-infer: cax-sco, cax-eqc1, cax-eqc2
      (list-push workers
        (spawn arena (fn ()
          (let ((t0 (now-ms))
                (mut result (make-delta arena-cax-infer next-iter)))
            (for-each (t (cax-sco arena-cax-infer g delta))
              (set! result (delta-add arena-cax-infer result t)))
            (for-each (t (cax-eqc1 arena-cax-infer g delta))
              (set! result (delta-add arena-cax-infer result t)))
            (for-each (t (cax-eqc2 arena-cax-infer g delta))
              (set! result (delta-add arena-cax-infer result t)))
            (when verbose
              (do (print "  cax-infer: ") (print-ms arena-cax-infer (- (now-ms) t0)) (println "")))
            (send result-chan (union-new WorkerMessage msg-delta result))
            (send result-chan (union-new WorkerMessage msg-done unit))))))

      ;; cax-check: cax-dw, cax-adc
      (list-push workers
        (spawn arena (fn ()
          (let ((t0 (now-ms)))
            (match (cax-dw arena-cax-check g delta)
              ((some report) (send result-chan (union-new WorkerMessage msg-inconsistent report)))
              ((none)
                (match (cax-adc arena-cax-check g delta)
                  ((some report) (send result-chan (union-new WorkerMessage msg-inconsistent report)))
                  ((none) (do)))))
            (when verbose
              (do (print "  cax-check: ") (print-ms arena-cax-check (- (now-ms) t0)) (println "")))
            (send result-chan (union-new WorkerMessage msg-done unit))))))

      ;; ---- PRP sub-workers (3) ----

      ;; prp-char: prp-dom, prp-rng, prp-fp, prp-ifp, prp-symp, prp-trp
      (list-push workers
        (spawn arena (fn ()
          (let ((t0 (now-ms))
                (mut result (make-delta arena-prp-char next-iter)))
            (for-each (t (prp-dom arena-prp-char g delta))
              (set! result (delta-add arena-prp-char result t)))
            (for-each (t (prp-rng arena-prp-char g delta))
              (set! result (delta-add arena-prp-char result t)))
            (for-each (t (prp-fp arena-prp-char g delta))
              (set! result (delta-add arena-prp-char result t)))
            (for-each (t (prp-ifp arena-prp-char g delta))
              (set! result (delta-add arena-prp-char result t)))
            (for-each (t (prp-symp arena-prp-char g delta))
              (set! result (delta-add arena-prp-char result t)))
            (for-each (t (prp-trp arena-prp-char g delta))
              (set! result (delta-add arena-prp-char result t)))
            (when verbose
              (do (print "  prp-char: ") (print-ms arena-prp-char (- (now-ms) t0)) (println "")))
            (send result-chan (union-new WorkerMessage msg-delta result))
            (send result-chan (union-new WorkerMessage msg-done unit))))))

      ;; prp-chain: prp-spo1, prp-eqp1, prp-eqp2, prp-inv1, prp-inv2
      (list-push workers
        (spawn arena (fn ()
          (let ((t0 (now-ms))
                (mut result (make-delta arena-prp-chain next-iter)))
            (for-each (t (prp-spo1 arena-prp-chain g delta))
              (set! result (delta-add arena-prp-chain result t)))
            (for-each (t (prp-eqp1 arena-prp-chain g delta))
              (set! result (delta-add arena-prp-chain result t)))
            (for-each (t (prp-eqp2 arena-prp-chain g delta))
              (set! result (delta-add arena-prp-chain result t)))
            (for-each (t (prp-inv1 arena-prp-chain g delta))
              (set! result (delta-add arena-prp-chain result t)))
            (for-each (t (prp-inv2 arena-prp-chain g delta))
              (set! result (delta-add arena-prp-chain result t)))
            (when verbose
              (do (print "  prp-chain: ") (print-ms arena-prp-chain (- (now-ms) t0)) (println "")))
            (send result-chan (union-new WorkerMessage msg-delta result))
            (send result-chan (union-new WorkerMessage msg-done unit))))))

      ;; prp-check: prp-asyp, prp-irp, prp-pdw
      (list-push workers
        (spawn arena (fn ()
          (let ((t0 (now-ms)))
            (match (prp-asyp arena-prp-check g delta)
              ((some report) (send result-chan (union-new WorkerMessage msg-inconsistent report)))
              ((none)
                (match (prp-irp arena-prp-check g delta)
                  ((some report) (send result-chan (union-new WorkerMessage msg-inconsistent report)))
                  ((none)
                    (match (prp-pdw arena-prp-check g delta)
                      ((some report) (send result-chan (union-new WorkerMessage msg-inconsistent report)))
                      ((none) (do)))))))
            (when verbose
              (do (print "  prp-check: ") (print-ms arena-prp-check (- (now-ms) t0)) (println "")))
            (send result-chan (union-new WorkerMessage msg-done unit))))))

      ;; ---- EQ sub-workers (2) ----

      ;; eq-infer: eq-sym, eq-trans, eq-rep-s, eq-rep-p, eq-rep-o
      (list-push workers
        (spawn arena (fn ()
          (let ((t0 (now-ms))
                (mut result (make-delta arena-eq-infer next-iter)))
            (for-each (t (eq-sym arena-eq-infer g delta))
              (set! result (delta-add arena-eq-infer result t)))
            (for-each (t (eq-trans arena-eq-infer g delta))
              (set! result (delta-add arena-eq-infer result t)))
            (for-each (t (eq-rep-s arena-eq-infer g delta))
              (set! result (delta-add arena-eq-infer result t)))
            (for-each (t (eq-rep-p arena-eq-infer g delta))
              (set! result (delta-add arena-eq-infer result t)))
            (for-each (t (eq-rep-o arena-eq-infer g delta))
              (set! result (delta-add arena-eq-infer result t)))
            (when verbose
              (do (print "  eq-infer: ") (print-ms arena-eq-infer (- (now-ms) t0)) (println "")))
            (send result-chan (union-new WorkerMessage msg-delta result))
            (send result-chan (union-new WorkerMessage msg-done unit))))))

      ;; eq-check: eq-diff1, eq-diff2, eq-diff3
      (list-push workers
        (spawn arena (fn ()
          (let ((t0 (now-ms)))
            (match (eq-diff1 arena-eq-check g delta)
              ((some report) (send result-chan (union-new WorkerMessage msg-inconsistent report)))
              ((none)
                (match (eq-diff2 arena-eq-check g delta)
                  ((some report) (send result-chan (union-new WorkerMessage msg-inconsistent report)))
                  ((none)
                    (match (eq-diff3 arena-eq-check g delta)
                      ((some report) (send result-chan (union-new WorkerMessage msg-inconsistent report)))
                      ((none) (do)))))))
            (when verbose
              (do (print "  eq-check: ") (print-ms arena-eq-check (- (now-ms) t0)) (println "")))
            (send result-chan (union-new WorkerMessage msg-done unit))))))

      ;; ---- CLS sub-workers (2) ----

      ;; cls-set: cls-int1, cls-int2, cls-uni, cls-svf1, cls-svf2, cls-avf
      (list-push workers
        (spawn arena (fn ()
          (let ((t0 (now-ms))
                (mut result (make-delta arena-cls-set next-iter)))
            (for-each (t (cls-int1 arena-cls-set g delta))
              (set! result (delta-add arena-cls-set result t)))
            (for-each (t (cls-int2 arena-cls-set g delta))
              (set! result (delta-add arena-cls-set result t)))
            (for-each (t (cls-uni arena-cls-set g delta))
              (set! result (delta-add arena-cls-set result t)))
            (for-each (t (cls-svf1 arena-cls-set g delta))
              (set! result (delta-add arena-cls-set result t)))
            (for-each (t (cls-svf2 arena-cls-set g delta))
              (set! result (delta-add arena-cls-set result t)))
            (for-each (t (cls-avf arena-cls-set g delta))
              (set! result (delta-add arena-cls-set result t)))
            (when verbose
              (do (print "  cls-set: ") (print-ms arena-cls-set (- (now-ms) t0)) (println "")))
            (send result-chan (union-new WorkerMessage msg-delta result))
            (send result-chan (union-new WorkerMessage msg-done unit))))))

      ;; cls-ind: cls-hv1, cls-hv2, cls-maxc1, cls-maxc2, cls-oo, cls-nothing2, cls-com
      (list-push workers
        (spawn arena (fn ()
          (let ((t0 (now-ms))
                (mut result (make-delta arena-cls-ind next-iter)))
            (for-each (t (cls-hv1 arena-cls-ind g delta))
              (set! result (delta-add arena-cls-ind result t)))
            (for-each (t (cls-hv2 arena-cls-ind g delta))
              (set! result (delta-add arena-cls-ind result t)))
            (for-each (t (cls-maxc1 arena-cls-ind g delta))
              (set! result (delta-add arena-cls-ind result t)))
            (for-each (t (cls-maxc2 arena-cls-ind g delta))
              (set! result (delta-add arena-cls-ind result t)))
            (for-each (t (cls-oo arena-cls-ind g delta))
              (set! result (delta-add arena-cls-ind result t)))
            ;; cls-nothing2 and cls-com are check rules
            (match (cls-nothing2 arena-cls-ind g delta)
              ((some report) (send result-chan (union-new WorkerMessage msg-inconsistent report)))
              ((none)
                (match (cls-com arena-cls-ind g delta)
                  ((some report) (send result-chan (union-new WorkerMessage msg-inconsistent report)))
                  ((none) (do)))))
            (when verbose
              (do (print "  cls-ind: ") (print-ms arena-cls-ind (- (now-ms) t0)) (println "")))
            (send result-chan (union-new WorkerMessage msg-delta result))
            (send result-chan (union-new WorkerMessage msg-done unit))))))

      workers))

  (fn collect-worker-results ((arena Arena) (result-chan (Ptr (Chan WorkerMessage)))
                              (workers (List (Ptr (Thread Unit))))
                              (next-iter (Int 0 ..)))
    (@intent "Collect all worker results and merge deltas into combined delta")
    (@spec ((Arena (Ptr (Chan WorkerMessage)) (List (Ptr (Thread Unit))) (Int 0 ..))
            -> (Result Delta InconsistencyReport)))
    (@alloc arena)
    (@pre {(list-len workers) == 12})
    (@pre {next-iter >= 1})
    (@post (match $result
             ((ok d) {(. d iteration) == next-iter})
             ((error _) true)))
    ;; Collect results from channel before joining
    (let ((mut combined (make-delta arena next-iter))
          (mut inconsistency (Option InconsistencyReport) (none))
          (mut done-count 0)
          (expected (list-len workers)))
      ;; Receive all messages until we get a msg-done from each worker
      (while (< done-count expected)
        (match (recv result-chan)
          ((ok msg)
            (match msg
              ((msg-delta d)
                (set! combined (delta-merge arena combined d)))
              ((msg-inconsistent r)
                (set! inconsistency (some r)))
              ((msg-done _)
                (set! done-count (+ done-count 1)))))
          ((error _)
            ;; Channel error, stop receiving
            (set! done-count expected))))
      ;; Join all workers to ensure they've completed
      (for-each (w workers)
        (join w))
      ;; Return inconsistency if found, otherwise merged delta
      (match inconsistency
        ((some r) (error r))
        ((none) (ok combined))))))
