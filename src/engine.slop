;; ============================================================
;; Growl Engine: Parallel Fixpoint Rule Evaluation
;;
;; Implements fork-join parallel semi-naive evaluation.
;; Each of the 5 rule groups (scm, cax, prp, eq, cls) runs
;; in its own thread with its own arena; results merge on
;; the coordinator thread.
;; ============================================================

(module engine
  (@doc "Parallel fixpoint rule engine with fork-join pattern")

  (import rdf (Term Triple triple-eq))
  (import index (IndexedGraph indexed-graph-add indexed-graph-contains indexed-graph-size indexed-graph-match indexed-graph-for-each))
  (import thread (chan-buffered send recv spawn join))
  (import types (Delta ReasonerConfig EngineState ReasonerResult ReasonerSuccess
                 InconsistencyReport make-delta delta-add delta-merge delta-is-empty))
  (import cax (apply-cax-rules))
  (import scm (apply-scm-rules))
  (import prp (apply-prp-rules))
  (import eq (apply-eq-rules))
  (import cls (apply-cls-rules))

  (export
    engine-run
    engine-run-iteration
    apply-all-rules
    merge-into-graph)

  ;; ============================================================
  ;; Types
  ;; ============================================================

  ;; Message from worker to coordinator
  (type WorkerMessage (union
    (msg-delta Delta)
    (msg-inconsistent InconsistencyReport)
    (msg-done Unit)))

  ;; ============================================================
  ;; Main Engine Loop
  ;; ============================================================

  (fn engine-run ((arena Arena) (config ReasonerConfig) (initial IndexedGraph))
    (@intent "Run parallel rules to fixpoint, return final graph or inconsistency")
    (@spec ((Arena ReasonerConfig IndexedGraph) -> ReasonerResult))
    (@alloc arena)
    (@pre {(. config worker-count) >= 1})
    (@pre {(. config max-iterations) >= 1})
    (@pre {(indexed-graph-size initial) >= 0})
    (@post (match $result
             ((reason-success s) {(. s iterations) <= (. config max-iterations)})
             ((reason-inconsistent _) true)))
    (let ((initial-size (indexed-graph-size initial))
          (mut state (record-new EngineState
                       (graph initial)
                       (delta (make-initial-delta arena initial))
                       (iteration 0)
                       (config config)))
          (mut done false)
          (mut inconsistency (Option InconsistencyReport) (none)))

      ;; Main fixpoint loop
      (while (and (not done) (< (. state iteration) (. config max-iterations)))
        (@loop-invariant {(. state iteration) <= (. config max-iterations)})
        (c-inline "fprintf(stderr, \"[engine] iter=%lld graph=%lld global_alloc=%zu MB\\n\", (long long)state.iteration, (long long)index_indexed_graph_size(state.graph), (size_t)(slop_global_allocated / (1024*1024)))")
        (match (engine-run-iteration arena state)
          ((ok new-state)
            (if (delta-is-empty (. new-state delta))
              (set! done true)
              (set! state new-state)))
          ((error report)
            (do
              (set! done true)
              (set! inconsistency (some report))))))

      ;; Return result
      (match inconsistency
        ((some report) (union-new ReasonerResult reason-inconsistent report))
        ((none)
          (union-new ReasonerResult reason-success (record-new ReasonerSuccess
            (graph (. state graph))
            (inferred-count (- (indexed-graph-size (. state graph)) initial-size))
            (iterations (. state iteration))))))))

  (fn make-initial-delta ((arena Arena) (g IndexedGraph))
    (@intent "Create initial delta containing all triples in graph")
    (@spec ((Arena IndexedGraph) -> Delta))
    (@alloc arena)
    (@post {(. $result iteration) == 0})
    (let ((mut d (make-delta arena 0)))
      ;; In first iteration, all triples are "new"
      (indexed-graph-for-each g (none) (none) (none)
        (fn ((t Triple))
          (set! d (delta-add arena d t))))
      d))

  ;; ============================================================
  ;; Single Iteration
  ;; ============================================================

  (fn engine-run-iteration ((arena Arena) (state EngineState))
    (@intent "Run one iteration of rule application across all workers")
    (@spec ((Arena EngineState) -> (Result EngineState InconsistencyReport)))
    (@alloc arena)
    (@pre {(. state iteration) >= 0})
    (@post (match $result
             ((ok new-state) {(. new-state iteration) == (+ (. state iteration) 1)})
             ((error _) true)))
    ;; Apply all rules to get new inferred triples
    (match (apply-all-rules arena (. state graph) (. state delta) (. state config))
      ((ok new-delta)
        ;; Merge new triples into graph and update state
        (ok (record-new EngineState
              (graph (merge-into-graph arena (. state graph) new-delta))
              (delta new-delta)
              (iteration (+ (. state iteration) 1))
              (config (. state config)))))
      ((error report)
        (error report))))

  ;; ============================================================
  ;; Rule Application: Dispatch
  ;; ============================================================

  (fn apply-all-rules ((arena Arena) (g IndexedGraph) (delta Delta) (config ReasonerConfig))
    (@intent "Apply all OWL 2 RL rules, dispatching to sequential or parallel path")
    (@spec ((Arena IndexedGraph Delta ReasonerConfig) -> (Result Delta InconsistencyReport)))
    (@alloc arena)
    (@pre {(indexed-graph-size g) >= 0})
    (@post (match $result
             ((ok d) {(. d iteration) == (+ (. delta iteration) 1)})
             ((error _) true)))
    ;; Iteration 0 always runs sequentially to pre-intern all vocabulary
    ;; strings in the global intern pool before concurrent access.
    ;; Single-worker config also uses sequential path.
    (if (or (<= (. config worker-count) 1) (== (. delta iteration) 0))
      (apply-all-rules-sequential arena g delta)
      (apply-all-rules-parallel arena g delta config)))

  ;; ============================================================
  ;; Rule Application: Sequential Path
  ;; ============================================================

  (fn apply-all-rules-sequential ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Apply all OWL 2 RL rules sequentially, return combined delta")
    (@spec ((Arena IndexedGraph Delta) -> (Result Delta InconsistencyReport)))
    (@alloc arena)
    (@pre {(indexed-graph-size g) >= 0})
    (@post (match $result
             ((ok d) {(. d iteration) == (+ (. delta iteration) 1)})
             ((error _) true)))
    (let ((next-iter (+ (. delta iteration) 1))
          (mut combined (make-delta arena next-iter)))

      ;; Apply each rule group sequentially

      (c-inline "fprintf(stderr, \"  [seq] before scm: %zu MB\\n\", (size_t)(slop_global_allocated / (1024*1024)))")
      ;; Schema rules first (often create subclass hierarchies)
      (match (apply-scm-rules arena g delta)
        ((ok scm-delta) (set! combined (delta-merge arena combined scm-delta)))
        ((error report) (return (error report))))

      (c-inline "fprintf(stderr, \"  [seq] after scm: %zu MB\\n\", (size_t)(slop_global_allocated / (1024*1024)))")
      ;; Class axiom rules (subclass propagation)
      (match (apply-cax-rules arena g delta)
        ((ok cax-delta) (set! combined (delta-merge arena combined cax-delta)))
        ((error report) (return (error report))))

      (c-inline "fprintf(stderr, \"  [seq] after cax: %zu MB\\n\", (size_t)(slop_global_allocated / (1024*1024)))")
      ;; Property rules
      (match (apply-prp-rules arena g delta)
        ((ok prp-delta) (set! combined (delta-merge arena combined prp-delta)))
        ((error report) (return (error report))))

      (c-inline "fprintf(stderr, \"  [seq] after prp: %zu MB\\n\", (size_t)(slop_global_allocated / (1024*1024)))")
      ;; Equality rules
      (match (apply-eq-rules arena g delta)
        ((ok eq-delta) (set! combined (delta-merge arena combined eq-delta)))
        ((error report) (return (error report))))

      (c-inline "fprintf(stderr, \"  [seq] after eq: %zu MB\\n\", (size_t)(slop_global_allocated / (1024*1024)))")
      ;; Class expression rules
      (match (apply-cls-rules arena g delta)
        ((ok cls-delta) (set! combined (delta-merge arena combined cls-delta)))
        ((error report) (return (error report))))
      (c-inline "fprintf(stderr, \"  [seq] after cls: %zu MB\\n\", (size_t)(slop_global_allocated / (1024*1024)))")

      ;; Each rule already checks (indexed-graph-contains g inferred) before adding,
      ;; and delta-add deduplicates across rules via (set-has seen t).
      (ok combined)))

  ;; ============================================================
  ;; Rule Application: Parallel Path (Fork-Join)
  ;; ============================================================

  (fn apply-all-rules-parallel ((arena Arena) (g IndexedGraph) (delta Delta) (config ReasonerConfig))
    (@intent "Apply all OWL 2 RL rules in parallel using fork-join, one thread per rule group")
    (@spec ((Arena IndexedGraph Delta ReasonerConfig) -> (Result Delta InconsistencyReport)))
    (@alloc arena)
    (@pre {(indexed-graph-size g) >= 0})
    (@pre {(. config worker-count) > 1})
    (@post (match $result
             ((ok d) {(. d iteration) == (+ (. delta iteration) 1)})
             ((error _) true)))
    (let ((next-iter (+ (. delta iteration) 1))
          (result-chan (chan-buffered WorkerMessage arena (. config channel-buffer)))
          ;; Allocate coordinator-owned per-worker arenas so data survives until collect
          (arena-scm (arena-new 1048576))
          (arena-cax (arena-new 1048576))
          (arena-prp (arena-new 1048576))
          (arena-eq  (arena-new 1048576))
          (arena-cls (arena-new 1048576)))

      ;; Spawn 5 workers, one per rule group, each with its coordinator-owned arena
      (let ((workers (spawn-rule-workers arena g delta result-chan
                                         arena-scm arena-cax arena-prp arena-eq arena-cls)))

        ;; Collect results from all workers
        (let ((result (collect-worker-results arena result-chan workers next-iter)))

          ;; Free worker arenas now that results have been merged into coordinator arena
          (arena-free arena-scm)
          (arena-free arena-cax)
          (arena-free arena-prp)
          (arena-free arena-eq)
          (arena-free arena-cls)

          ;; Each rule already checks (indexed-graph-contains g inferred) before adding,
          ;; and delta-add deduplicates across rules via (set-has seen t).
          result))))

  ;; ============================================================
  ;; Graph Merging
  ;; ============================================================

  (fn merge-into-graph ((arena Arena) (g IndexedGraph) (d Delta))
    (@intent "Add all triples from delta into graph")
    (@spec ((Arena IndexedGraph Delta) -> IndexedGraph))
    (@alloc arena)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(indexed-graph-size $result) >= (indexed-graph-size g)})
    (@post {(indexed-graph-size $result) <= (+ (indexed-graph-size g) (list-len (. d triples)))})
    (let ((mut result g))
      (for-each (t (. d triples))
        (set! result (indexed-graph-add arena result t)))
      result))

  ;; ============================================================
  ;; Parallel Worker Management
  ;; ============================================================

  (fn spawn-rule-workers ((arena Arena) (g IndexedGraph) (delta Delta)
                          (result-chan (Ptr (Chan WorkerMessage)))
                          (arena-scm Arena) (arena-cax Arena) (arena-prp Arena)
                          (arena-eq Arena) (arena-cls Arena))
    (@intent "Spawn 5 worker threads, one per rule group, each with coordinator-owned arena")
    (@spec ((Arena IndexedGraph Delta (Ptr (Chan WorkerMessage)) Arena Arena Arena Arena Arena)
            -> (List (Ptr (Thread Unit)))))
    (@alloc arena)
    (@post {(list-len $result) == 5})
    (let ((mut workers (list-new arena (Ptr (Thread Unit)))))

      ;; Worker 1: Schema rules (scm)
      (list-push workers
        (spawn arena (fn ()
          (match (apply-scm-rules arena-scm g delta)
            ((ok d) (send result-chan (union-new WorkerMessage msg-delta d)))
            ((error r) (send result-chan (union-new WorkerMessage msg-inconsistent r))))
          (send result-chan (union-new WorkerMessage msg-done unit)))))

      ;; Worker 2: Class axiom rules (cax)
      (list-push workers
        (spawn arena (fn ()
          (match (apply-cax-rules arena-cax g delta)
            ((ok d) (send result-chan (union-new WorkerMessage msg-delta d)))
            ((error r) (send result-chan (union-new WorkerMessage msg-inconsistent r))))
          (send result-chan (union-new WorkerMessage msg-done unit)))))

      ;; Worker 3: Property rules (prp)
      (list-push workers
        (spawn arena (fn ()
          (match (apply-prp-rules arena-prp g delta)
            ((ok d) (send result-chan (union-new WorkerMessage msg-delta d)))
            ((error r) (send result-chan (union-new WorkerMessage msg-inconsistent r))))
          (send result-chan (union-new WorkerMessage msg-done unit)))))

      ;; Worker 4: Equality rules (eq)
      (list-push workers
        (spawn arena (fn ()
          (match (apply-eq-rules arena-eq g delta)
            ((ok d) (send result-chan (union-new WorkerMessage msg-delta d)))
            ((error r) (send result-chan (union-new WorkerMessage msg-inconsistent r))))
          (send result-chan (union-new WorkerMessage msg-done unit)))))

      ;; Worker 5: Class expression rules (cls)
      (list-push workers
        (spawn arena (fn ()
          (match (apply-cls-rules arena-cls g delta)
            ((ok d) (send result-chan (union-new WorkerMessage msg-delta d)))
            ((error r) (send result-chan (union-new WorkerMessage msg-inconsistent r))))
          (send result-chan (union-new WorkerMessage msg-done unit)))))

      workers))

  (fn collect-worker-results ((arena Arena) (result-chan (Ptr (Chan WorkerMessage)))
                              (workers (List (Ptr (Thread Unit))))
                              (next-iter (Int 0 ..)))
    (@intent "Collect all worker results and merge deltas into combined delta")
    (@spec ((Arena (Ptr (Chan WorkerMessage)) (List (Ptr (Thread Unit))) (Int 0 ..))
            -> (Result Delta InconsistencyReport)))
    (@alloc arena)
    (@pre {(list-len workers) == 5})
    (@pre {next-iter >= 1})
    (@post (match $result
             ((ok d) {(. d iteration) == next-iter})
             ((error _) true)))
    ;; Collect results from channel before joining
    (let ((mut combined (make-delta arena next-iter))
          (mut inconsistency (Option InconsistencyReport) (none))
          (mut done-count 0)
          (expected (list-len workers)))
      ;; Receive all messages until we get a msg-done from each worker
      (while (< done-count expected)
        (match (recv result-chan)
          ((ok msg)
            (match msg
              ((msg-delta d)
                (set! combined (delta-merge arena combined d)))
              ((msg-inconsistent r)
                (set! inconsistency (some r)))
              ((msg-done _)
                (set! done-count (+ done-count 1)))))
          ((error _)
            ;; Channel error, stop receiving
            (set! done-count expected))))
      ;; Join all workers to ensure they've completed
      (for-each (w workers)
        (join w))
      ;; Return inconsistency if found, otherwise merged delta
      (match inconsistency
        ((some r) (error r))
        ((none) (ok combined))))))
