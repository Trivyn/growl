;; ============================================================
;; Growl Engine: Parallel Fixpoint Rule Evaluation
;;
;; Implements fork-join parallel semi-naive evaluation.
;; 12 semantic sub-workers split across 5 rule groups
;; (scm, cax, prp, eq, cls), each with its own thread
;; and arena; results merge on the coordinator thread.
;; ============================================================

(module engine
  (@doc "Parallel fixpoint rule engine with fork-join pattern")

  (import rdf (Term Triple triple-eq term-eq make-iri make-triple make-blank triple-subject triple-predicate triple-object))
  (import index (IndexedGraph indexed-graph-add indexed-graph-contains indexed-graph-size indexed-graph-match indexed-graph-for-each))
  (import vocab (RDF_TYPE RDF_PROPERTY RDFS_SUBCLASS_OF RDFS_SUBPROPERTY_OF RDFS_DOMAIN RDFS_RANGE
                 OWL_CLASS OWL_THING OWL_NOTHING OWL_EQUIVALENT_CLASS OWL_SAME_AS
                 OWL_DIFFERENT_FROM OWL_SYMMETRIC_PROPERTY
                 OWL_OBJECT_PROPERTY OWL_DATATYPE_PROPERTY OWL_FUNCTIONAL_PROPERTY
                 OWL_INVERSE_FUNCTIONAL_PROPERTY OWL_TRANSITIVE_PROPERTY
                 OWL_ASYMMETRIC_PROPERTY OWL_REFLEXIVE_PROPERTY OWL_IRREFLEXIVE_PROPERTY))
  (import thread (chan-buffered send recv spawn join))
  (import strlib (starts-with))
  (import types (Delta ReasonerConfig EngineState ReasonerResult ReasonerSuccess
                 InconsistencyReport make-delta delta-add delta-merge delta-is-empty))
  (import cax (apply-cax-rules cax-sco cax-eqc1 cax-eqc2 cax-dw cax-adc))
  (import scm (scm-cls scm-eqc1 scm-eqc1b scm-eqc2 scm-int scm-uni
               scm-op scm-dp scm-eqp1 scm-eqp1b scm-eqp2
               scm-dom1 scm-dom2 scm-rng1 scm-rng2
               scm-svf1 scm-svf2 scm-avf1 scm-avf2 scm-hv))
  (import prp (apply-prp-rules prp-dom prp-rng prp-fp prp-ifp prp-symp prp-trp
               prp-asyp prp-irp prp-pdw prp-adp prp-npa1 prp-npa2
               prp-spo1 prp-spo2 prp-eqp1 prp-eqp2 prp-inv1 prp-inv2 prp-key
               prp-ap))
  (import eq  (apply-eq-rules eq-ref eq-sym eq-trans eq-rep-s eq-rep-p eq-rep-o
               eq-diff1 eq-diff2 eq-diff3))
  (import cls (apply-cls-rules cls-thing cls-nothing1 cls-nothing2 cls-int1 cls-int2 cls-uni cls-com
               cls-svf1 cls-svf2 cls-avf cls-hv1 cls-hv2 cls-maxc1 cls-maxc2
               cls-maxqc1 cls-maxqc2 cls-maxqc3 cls-maxqc4 cls-oo))
  (import dt (dt-type1 dt-type2 dt-not-type))

  (export
    engine-run
    engine-run-iteration
    apply-all-rules
    merge-into-graph
    schema-materialize
    print-ms)

  ;; ============================================================
  ;; Types
  ;; ============================================================

  ;; Message from worker to coordinator
  (type WorkerMessage (union
    (msg-delta Delta)
    (msg-inconsistent InconsistencyReport)
    (msg-done Unit)))

  ;; Result of synthetic instance injection for --validate mode
  ;; class-map[i] = the class assigned blank ID 10M+i
  ;; prop-map[j] = the property assigned blank IDs 20M+j (subject) / 30M+j (object)
  (type ValidateInjection (record
    (graph IndexedGraph)
    (class-map (List Term))
    (prop-map (List Term))))

  ;; ============================================================
  ;; Timing Helpers
  ;; ============================================================

  (fn print-ms ((arena Arena) (ms I64))
    (@intent "Print a millisecond duration like '12ms'")
    (@spec ((Arena I64) -> Unit))
    (print (int-to-string arena ms))
    (print "ms"))

  ;; ============================================================
  ;; Synthetic Instance Injection (--validate mode)
  ;; ============================================================

  (fn collect-declared-properties ((arena Arena) (g IndexedGraph))
    (@intent "Collect all unique declared properties across 10 property metaclasses")
    (@spec ((Arena IndexedGraph) -> (List Term)))
    (@alloc arena)
    (let ((type-pred (make-iri arena RDF_TYPE))
          (no-term (Option Term) (none))
          (mut seen (set-new arena Term))
          (mut result (list-new arena Term))
          ;; 10 property metaclasses (excluding AnnotationProperty)
          (mut meta-types (list-new arena Term)))
      (list-push meta-types (make-iri arena OWL_OBJECT_PROPERTY))
      (list-push meta-types (make-iri arena OWL_DATATYPE_PROPERTY))
      (list-push meta-types (make-iri arena RDF_PROPERTY))
      (list-push meta-types (make-iri arena OWL_FUNCTIONAL_PROPERTY))
      (list-push meta-types (make-iri arena OWL_INVERSE_FUNCTIONAL_PROPERTY))
      (list-push meta-types (make-iri arena OWL_TRANSITIVE_PROPERTY))
      (list-push meta-types (make-iri arena OWL_SYMMETRIC_PROPERTY))
      (list-push meta-types (make-iri arena OWL_ASYMMETRIC_PROPERTY))
      (list-push meta-types (make-iri arena OWL_REFLEXIVE_PROPERTY))
      (list-push meta-types (make-iri arena OWL_IRREFLEXIVE_PROPERTY))
      (for-each (mt meta-types)
        (let ((matches (indexed-graph-match arena g no-term (some type-pred) (some mt))))
          (for-each (t matches)
            (let ((prop (triple-subject t)))
              (when (not (set-has seen prop))
                (do
                  (set-put seen prop)
                  (list-push result prop)))))))
      result))

  (fn iri-matches-ns ((term Term) (ns String))
    (@intent "Check if a term is an IRI that starts with the given namespace prefix")
    (@spec ((Term String) -> Bool))
    (@pure)
    (match term
      ((term-iri iri)
        (if (== (. ns len) 0)
          true
          (starts-with (. iri value) ns)))
      (_ false)))

  (fn inject-validate-instances ((arena Arena) (g IndexedGraph) (verbose Bool) (validate-ns String))
    (@intent "Inject synthetic blank node instances for each declared owl:Class and property usage")
    (@spec ((Arena IndexedGraph Bool String) -> ValidateInjection))
    (@alloc arena)
    (let ((type-pred (make-iri arena RDF_TYPE))
          (class-type (make-iri arena OWL_CLASS))
          (no-term (Option Term) (none))
          ;; Find all (?c rdf:type owl:Class) triples
          (class-triples (indexed-graph-match arena g no-term (some type-pred) (some class-type)))
          (mut result g)
          (mut count 0)
          ;; Build class-map: class-map[i] = class assigned blank ID 10M+i
          (mut class-map (list-new arena Term)))
      ;; Phase 1: Inject synthetic class instances (_:10M+N rdf:type C)
      (for-each (t class-triples)
        (let ((cls (triple-subject t)))
          (when (iri-matches-ns cls validate-ns)
            (do
              (let ((synthetic (make-blank arena (+ 10000000 count)))
                    (type-triple (make-triple arena synthetic type-pred cls)))
                (set! result (indexed-graph-add arena result type-triple))
                (list-push class-map cls)
                (set! count (+ count 1)))))))
      (when verbose
        (do
          (print "[validate] injected ")
          (print (int-to-string arena count))
          (println " synthetic class instances")))
      ;; Phase 2: Inject synthetic property usages (_:20M+N P _:30M+N)
      (let ((props (collect-declared-properties arena g))
            (mut prop-count 0)
            (mut prop-map (list-new arena Term)))
        (for-each (p props)
          (when (iri-matches-ns p validate-ns)
            (do
              (let ((subj-blank (make-blank arena (+ 20000000 prop-count)))
                    (obj-blank (make-blank arena (+ 30000000 prop-count)))
                    (prop-triple (make-triple arena subj-blank p obj-blank)))
                (set! result (indexed-graph-add arena result prop-triple))
                (list-push prop-map p)
                (set! prop-count (+ prop-count 1))))))
        (when verbose
          (do
            (print "[validate] injected ")
            (print (int-to-string arena prop-count))
            (println " synthetic property usages")))
        (record-new ValidateInjection
          (graph result)
          (class-map class-map)
          (prop-map prop-map)))))

  ;; ============================================================
  ;; Validate Report Enrichment
  ;; ============================================================

  (fn resolve-blank-class ((arena Arena) (blank-id Int) (class-map (List Term)))
    (@intent "Resolve synthetic class blank ID to class IRI name, or empty string")
    (@spec ((Arena Int (List Term)) -> String))
    (@alloc arena)
    (if (and (>= blank-id 10000000) (< blank-id 20000000))
      (let ((class-index (- blank-id 10000000)))
        (match (list-get class-map class-index)
          ((some cls)
            (match cls
              ((term-iri iri) (. iri value))
              (_ "")))
          ((none) "")))
      ""))

  (fn resolve-blank-prop ((arena Arena) (blank-id Int) (prop-map (List Term)))
    (@intent "Resolve synthetic property blank ID to property IRI name, or empty string")
    (@spec ((Arena Int (List Term)) -> String))
    (@alloc arena)
    (if (and (>= blank-id 20000000) (< blank-id 40000000))
      (let ((prop-index (if (< blank-id 30000000)
                          (- blank-id 20000000)
                          (- blank-id 30000000))))
        (match (list-get prop-map prop-index)
          ((some prop)
            (match prop
              ((term-iri iri) (. iri value))
              (_ "")))
          ((none) "")))
      ""))

  (fn build-enriched-reason ((arena Arena) (class-name String) (prop-name String) (original-reason String) (detail String))
    (@intent "Build enriched validation reason string from entity info")
    (@spec ((Arena String String String String) -> String))
    (@alloc arena)
    (let ((reason-suffix (if (> (string-len detail) 0)
                            (string-concat arena original-reason (string-concat arena ": " detail))
                            original-reason)))
      (if (> (string-len class-name) 0)
        (string-concat arena
          (string-concat arena "Unsatisfiable class: " class-name)
          (string-concat arena " (" (string-concat arena reason-suffix ")")))
        (if (> (string-len prop-name) 0)
          (string-concat arena
            (string-concat arena "Unsatisfiable property usage: " prop-name)
            (string-concat arena " (" (string-concat arena reason-suffix ")")))
          reason-suffix))))

  (fn enrich-validate-report ((arena Arena) (report InconsistencyReport) (pre-inject-graph IndexedGraph) (validate-ns String) (class-map (List Term)) (prop-map (List Term)))
    (@intent "Enrich validate inconsistency report with unsatisfiable class or property IRI")
    (@spec ((Arena InconsistencyReport IndexedGraph String (List Term) (List Term)) -> InconsistencyReport))
    (@alloc arena)
    (let ((witnesses (. report witnesses))
          (original-reason (. report reason)))
      (if (starts-with original-reason "cax-dw")
        ;; === cax-dw: Extract disjoint classes directly from witnesses ===
        ;; witnesses[0] = (individual rdf:type classX)
        ;; witnesses[2] = (classA owl:disjointWith classB)
        (match (list-get witnesses 2)
          ((some dj-witness)
            (let ((class-a (triple-subject dj-witness))
                  (class-b (triple-object dj-witness)))
              (match class-a
                ((term-iri iri-a)
                  (match class-b
                    ((term-iri iri-b)
                      (let ((detail (string-concat arena (. iri-a value)
                                      (string-concat arena " disjointWith " (. iri-b value)))))
                        ;; Resolve source entity from first witness subject
                        (match (list-get witnesses 0)
                          ((some first-witness)
                            (let ((subj (triple-subject first-witness)))
                              (match subj
                                ((term-blank bnode)
                                  (let ((class-name (resolve-blank-class arena (. bnode id) class-map))
                                        (prop-name (resolve-blank-prop arena (. bnode id) prop-map))
                                        (enriched (build-enriched-reason arena class-name prop-name original-reason detail)))
                                    ;; For properties, append domain-intersection note if applicable
                                    (if (> (string-len prop-name) 0)
                                      (let ((blank-id (. bnode id))
                                            (prop-index (if (< blank-id 30000000) (- blank-id 20000000) (- blank-id 30000000)))
                                            (mut domain-count Int 0))
                                        (match (list-get prop-map prop-index)
                                          ((some prop-term)
                                            (let ((domain-pred (make-iri arena RDFS_DOMAIN))
                                                  (no-term (Option Term) (none))
                                                  (domains (indexed-graph-match arena pre-inject-graph (some prop-term) (some domain-pred) no-term)))
                                              (set! domain-count (list-len domains))))
                                          ((none) (do)))
                                        (let ((final-reason (if (> domain-count 1)
                                                              (string-concat arena enriched
                                                                (string-concat arena "\n  Note: "
                                                                  (string-concat arena prop-name
                                                                    (string-concat arena " has "
                                                                      (string-concat arena (int-to-string arena domain-count)
                                                                        " rdfs:domain declarations (OWL treats multiple domains as intersection, not union).\n  Consider using owl:unionOf if union semantics were intended.")))))
                                                              enriched)))
                                          (record-new InconsistencyReport
                                            (reason final-reason)
                                            (witnesses witnesses))))
                                      (record-new InconsistencyReport
                                        (reason enriched)
                                        (witnesses witnesses)))))
                                (_ ;; Non-blank subject — fallback with detail only
                                  (let ((enriched (build-enriched-reason arena "" "" original-reason detail)))
                                    (record-new InconsistencyReport
                                      (reason enriched)
                                      (witnesses witnesses)))))))
                          ((none) ;; No first witness — fallback with detail only
                            (let ((enriched (build-enriched-reason arena "" "" original-reason detail)))
                              (record-new InconsistencyReport
                                (reason enriched)
                                (witnesses witnesses)))))))
                    (_ report)))
                (_ report))))
          ((none) report))

        (if (starts-with original-reason "cax-adc")
          ;; === cax-adc: Extract disjoint classes from AllDisjointClasses witnesses ===
          ;; witnesses[0] = (individual rdf:type class-a)
          ;; witnesses[1] = (individual rdf:type class-b)
          ;; witnesses[2] = (adc-node rdf:type owl:AllDisjointClasses)
          (match (list-get witnesses 0)
            ((some w0)
              (match (list-get witnesses 1)
                ((some w1)
                  (let ((class-a (triple-object w0))
                        (class-b (triple-object w1))
                        (subj (triple-subject w0)))
                    (match class-a
                      ((term-iri iri-a)
                        (match class-b
                          ((term-iri iri-b)
                            (let ((detail (string-concat arena (. iri-a value)
                                            (string-concat arena " disjointWith " (string-concat arena (. iri-b value) " (via AllDisjointClasses)")))))
                              (match subj
                                ((term-blank bnode)
                                  (let ((class-name (resolve-blank-class arena (. bnode id) class-map))
                                        (prop-name (resolve-blank-prop arena (. bnode id) prop-map))
                                        (enriched (build-enriched-reason arena class-name prop-name original-reason detail)))
                                    (record-new InconsistencyReport
                                      (reason enriched)
                                      (witnesses witnesses))))
                                (_ (let ((enriched (build-enriched-reason arena "" "" original-reason detail)))
                                     (record-new InconsistencyReport
                                       (reason enriched)
                                       (witnesses witnesses)))))))
                          (_ report)))
                      (_ report))))
                ((none) report)))
            ((none) report))

          ;; === Non-cax-dw/cax-adc: blank-ID-based entity resolution ===
          (match (list-get witnesses 0)
            ((some first-witness)
              (let ((subj (triple-subject first-witness)))
                (match subj
                  ((term-blank bnode)
                    (let ((class-name (resolve-blank-class arena (. bnode id) class-map))
                          (prop-name (resolve-blank-prop arena (. bnode id) prop-map)))
                      (if (> (string-len class-name) 0)
                        ;; Class entity — straightforward
                        (let ((enriched (build-enriched-reason arena class-name "" original-reason "")))
                          (record-new InconsistencyReport
                            (reason enriched)
                            (witnesses witnesses)))
                        (if (> (string-len prop-name) 0)
                          ;; Property entity — check if we should trace to class via domain/range
                          (let ((witness-pred (triple-predicate first-witness))
                                (type-pred (make-iri arena RDF_TYPE)))
                            (if (term-eq witness-pred type-pred)
                              ;; rdf:type witness → class-level rule fired via domain/range, trace back
                              (let ((blank-id (. bnode id))
                                    (prop-index (if (< blank-id 30000000) (- blank-id 20000000) (- blank-id 30000000))))
                                (match (list-get prop-map prop-index)
                                  ((some prop)
                                    (let ((domain-or-range-pred (make-iri arena (if (< blank-id 30000000) RDFS_DOMAIN RDFS_RANGE)))
                                          (no-term (Option Term) (none))
                                          (class-triples (indexed-graph-match arena pre-inject-graph
                                                           (some prop) (some domain-or-range-pred) no-term)))
                                      (match (list-get class-triples 0)
                                        ((some class-triple)
                                          (let ((cls (triple-object class-triple)))
                                            (if (iri-matches-ns cls validate-ns)
                                              ;; Domain/range class matches namespace — report as class
                                              (match cls
                                                ((term-iri iri)
                                                  (let ((enriched (build-enriched-reason arena (. iri value) "" original-reason "")))
                                                    (record-new InconsistencyReport
                                                      (reason enriched)
                                                      (witnesses witnesses))))
                                                (_ report))
                                              ;; Doesn't match namespace — report property
                                              (let ((enriched (build-enriched-reason arena "" prop-name original-reason "")))
                                                (record-new InconsistencyReport
                                                  (reason enriched)
                                                  (witnesses witnesses))))))
                                        ((none)
                                          ;; No domain/range found — report property
                                          (let ((enriched (build-enriched-reason arena "" prop-name original-reason "")))
                                            (record-new InconsistencyReport
                                              (reason enriched)
                                              (witnesses witnesses)))))))
                                  ((none) report)))
                              ;; Non-rdf:type witness → property-level rule
                              (let ((enriched (build-enriched-reason arena "" prop-name original-reason "")))
                                (record-new InconsistencyReport
                                  (reason enriched)
                                  (witnesses witnesses)))))
                          ;; Neither class nor property resolved
                          report))))
                  (_ report))))
            ((none) report))))))

  ;; ============================================================
  ;; Main Engine Loop
  ;; ============================================================

  (fn engine-run ((arena Arena) (config ReasonerConfig) (initial IndexedGraph))
    (@intent "Run parallel rules to fixpoint, return final graph or inconsistency")
    (@spec ((Arena ReasonerConfig IndexedGraph) -> ReasonerResult))
    (@alloc arena)
    (@pre {(. config worker-count) >= 1})
    (@pre {(. config max-iterations) >= 1})
    (@pre {(indexed-graph-size initial) >= 0})
    (@post (match $result
             ((reason-success s) {(. s iterations) <= (. config max-iterations)})
             ((reason-inconsistent _) true)))
    (let ((initial-size (indexed-graph-size initial))
          (initial-delta (make-initial-delta arena initial))
          ;; Phase 1: Schema materialization (skip in fast mode)
          (materialized-graph
            (if (. config fast)
              initial
              (schema-materialize arena initial
                (make-initial-delta arena initial) config)))
          ;; dt-type1: assert supported datatypes as rdfs:Datatype (skip in fast mode)
          (dt-graph
            (if (. config fast)
              materialized-graph
              (let ((mut mg materialized-graph))
                (for-each (t (dt-type1 arena mg))
                  (set! mg (indexed-graph-add arena mg t)))
                mg)))
          ;; One-time axioms (only with --complete, skip in fast mode):
          ;; prp-ap: assert standard annotation properties
          ;; cls-thing: owl:Thing rdf:type owl:Class
          ;; cls-nothing1: owl:Nothing rdf:type owl:Class
          (complete-graph
            (if (and (not (. config fast)) (. config complete))
              (let ((mut cg dt-graph))
                (for-each (t (prp-ap arena cg))
                  (set! cg (indexed-graph-add arena cg t)))
                (for-each (t (cls-thing arena cg))
                  (set! cg (indexed-graph-add arena cg t)))
                (for-each (t (cls-nothing1 arena cg))
                  (set! cg (indexed-graph-add arena cg t)))
                ;; dt-type2: assert literal rdf:type datatype for typed literals
                (for-each (t (dt-type2 arena cg))
                  (set! cg (indexed-graph-add arena cg t)))
                ;; Generate scm-cls triples for Thing and Nothing
                ;; (scm-cls already ran, but these axioms were added after)
                (let ((thing (make-iri arena OWL_THING))
                      (nothing (make-iri arena OWL_NOTHING))
                      (subclass-pred (make-iri arena RDFS_SUBCLASS_OF))
                      (equiv-pred (make-iri arena OWL_EQUIVALENT_CLASS)))
                  (set! cg (indexed-graph-add arena cg (make-triple arena thing subclass-pred thing)))
                  (set! cg (indexed-graph-add arena cg (make-triple arena thing equiv-pred thing)))
                  (set! cg (indexed-graph-add arena cg (make-triple arena nothing subclass-pred nothing)))
                  (set! cg (indexed-graph-add arena cg (make-triple arena nothing equiv-pred nothing)))
                  ;; Nothing subClassOf Thing (scm-cls would produce this if Nothing were
                  ;; declared as owl:Class before schema materialization)
                  (set! cg (indexed-graph-add arena cg (make-triple arena nothing subclass-pred thing))))
                ;; eq-ref axiomatic: sameAs sameAs sameAs
                ;; (eq-ref adds results to graph not delta, so this self-referential
                ;; triple can't emerge from the fixpoint loop)
                (let ((same-as (make-iri arena OWL_SAME_AS)))
                  (set! cg (indexed-graph-add arena cg (make-triple arena same-as same-as same-as))))
                ;; owl:differentFrom is symmetric — declare it so prp-symp handles it
                (let ((type-pred (make-iri arena RDF_TYPE)))
                  (set! cg (indexed-graph-add arena cg
                    (make-triple arena
                      (make-iri arena OWL_DIFFERENT_FROM)
                      type-pred
                      (make-iri arena OWL_SYMMETRIC_PROPERTY)))))
                cg)
              dt-graph))
          ;; Phase 2a: Inject synthetic instances for --validate mode
          (validate-injection
            (if (. config validate)
              (inject-validate-instances arena complete-graph (. config verbose) (. config validate-ns))
              (record-new ValidateInjection
                (graph complete-graph)
                (class-map (list-new arena Term))
                (prop-map (list-new arena Term)))))
          (validate-graph (. validate-injection graph))
          (validate-class-map (. validate-injection class-map))
          (validate-prop-map (. validate-injection prop-map))
          ;; Phase 2b: Main fixpoint uses (possibly augmented) graph
          ;; In validate mode, recreate delta from the augmented graph
          ;; so synthetic type triples are seen as "new" by the rules
          (fixpoint-delta
            (if (. config validate)
              (make-initial-delta arena validate-graph)
              initial-delta))
          (mut state (record-new EngineState
                       (graph validate-graph)
                       (delta fixpoint-delta)
                       (iteration 0)
                       (config config)))
          (mut done false)
          (mut inconsistency (Option InconsistencyReport) (none)))

      ;; One-time datatype validation (skip in fast mode)
      (when (not (. config fast))
        (match (dt-not-type arena (. state graph))
          ((some report)
            (return (union-new ReasonerResult reason-inconsistent report)))
          ((none) (do))))

      ;; Main fixpoint loop
      (while (and (not done) (< (. state iteration) (. config max-iterations)))
        (@loop-invariant {(. state iteration) <= (. config max-iterations)})
        (when (. config verbose)
          (do
            (print "[iter ")
            (print (int-to-string arena (. state iteration)))
            (print "] graph=")
            (print (int-to-string arena (indexed-graph-size (. state graph))))
            (println "")))
        (match (engine-run-iteration arena state)
          ((ok new-state)
            (set! state new-state)
            (when (delta-is-empty (. new-state delta))
              (set! done true)))
          ((error report)
            (do
              (set! done true)
              (set! inconsistency (some report))))))

      ;; Return result
      (match inconsistency
        ((some report)
          (let ((final-report
                  (if (. config validate)
                    (enrich-validate-report arena report complete-graph (. config validate-ns) validate-class-map validate-prop-map)
                    report)))
            (union-new ReasonerResult reason-inconsistent final-report)))
        ((none)
          ;; In complete mode, do one final eq-ref pass on full graph
          ;; to cover schema-materialized resources
          (let ((mut final-graph (. state graph)))
            (when (. config complete)
              (let ((full-delta (make-initial-delta arena final-graph)))
                (for-each (t (eq-ref arena final-graph full-delta))
                  (set! final-graph (indexed-graph-add arena final-graph t)))))
            (union-new ReasonerResult reason-success (record-new ReasonerSuccess
              (graph final-graph)
              (inferred-count (- (indexed-graph-size final-graph) initial-size))
              (iterations (. state iteration)))))))))

  (fn make-initial-delta ((arena Arena) (g IndexedGraph))
    (@intent "Create initial delta containing all triples in graph")
    (@spec ((Arena IndexedGraph) -> Delta))
    (@alloc arena)
    (@post {(. $result iteration) == 0})
    (let ((mut d (make-delta arena 0)))
      ;; In first iteration, all triples are "new"
      (indexed-graph-for-each g (none) (none) (none)
        (fn ((t Triple))
          (set! d (delta-add arena d t))))
      d))

  ;; ============================================================
  ;; Direct Transitive Closure (BFS)
  ;; ============================================================

  (fn compute-tc ((arena Arena) (g IndexedGraph) (pred Term))
    (@intent "Direct transitive closure via BFS for a single predicate")
    (@spec ((Arena IndexedGraph Term) -> (List Triple)))
    (@alloc arena)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@property novelty
      ;; No output triple is already in the graph
      (forall (t $result) (not (indexed-graph-contains g t))))
    (@property predicate-preservation
      ;; Every output triple uses the given predicate
      (forall (t $result)
        (term-eq (triple-predicate t) pred)))
    (let ((no-term (Option Term) (none))
          (mut result (list-new arena Triple))
          ;; Collect all triples with this predicate to find unique subjects
          (all-pred-triples (indexed-graph-match arena g no-term (some pred) no-term))
          (mut all-subjects (list-new arena Term))
          (mut seen-subjects (set-new arena Term)))
      ;; Deduplicate subjects
      (for-each (t all-pred-triples)
        (let ((s (triple-subject t)))
          (when (not (set-has seen-subjects s))
            (do
              (set-put seen-subjects s)
              (list-push all-subjects s)))))
      ;; BFS from each subject to find all ancestors
      (for-each (start all-subjects)
        (let ((mut bfs-visited (set-new arena Term))
              (mut bfs-queue (list-new arena Term)))
          ;; Seed: direct parents of start
          (let ((direct-parents (indexed-graph-match arena g (some start) (some pred) no-term)))
            (for-each (t direct-parents)
              (let ((parent (triple-object t)))
                (when (not (set-has bfs-visited parent))
                  (do
                    (set-put bfs-visited parent)
                    (list-push bfs-queue parent))))))
          ;; BFS loop
          (let ((mut qi 0))
            (while (< qi (list-len bfs-queue))
              (match (list-get bfs-queue qi)
                ((some current)
                  (do
                    (let ((inferred (make-triple arena start pred current)))
                      (when (not (indexed-graph-contains g inferred))
                        (list-push result inferred)))
                    ;; Enqueue current's parents
                    (let ((parents (indexed-graph-match arena g (some current) (some pred) no-term)))
                      (for-each (t parents)
                        (let ((parent (triple-object t)))
                          (when (not (set-has bfs-visited parent))
                            (do
                              (set-put bfs-visited parent)
                              (list-push bfs-queue parent))))))))
                ((none) (do)))
              (set! qi (+ qi 1))))))
      result))

  ;; ============================================================
  ;; Schema Materialization Phase
  ;; ============================================================

  (fn schema-materialize ((arena Arena) (g IndexedGraph) (delta Delta) (config ReasonerConfig))
    (@intent "Run schema rules via phased pipeline with direct transitive closure")
    (@spec ((Arena IndexedGraph Delta ReasonerConfig) -> IndexedGraph))
    (@alloc arena)
    (let ((mut graph g)
          (verbose (. config verbose))
          (subclass-pred (make-iri arena RDFS_SUBCLASS_OF))
          (subprop-pred (make-iri arena RDFS_SUBPROPERTY_OF)))

      (when verbose
        (println "[schema] phased materialization"))

      ;; Phase 1: Bootstrap — scm-cls, scm-op, scm-dp
      ;; These read rdf:type (never produced by scm rules), single pass
      (let ((t0 (now-ms))
            (mut count 0))
        (for-each (t (scm-cls arena graph delta))
          (do (set! graph (indexed-graph-add arena graph t))
              (set! count (+ count 1))))
        (for-each (t (scm-op arena graph delta))
          (do (set! graph (indexed-graph-add arena graph t))
              (set! count (+ count 1))))
        (for-each (t (scm-dp arena graph delta))
          (do (set! graph (indexed-graph-add arena graph t))
              (set! count (+ count 1))))
        (when verbose
          (do
            (print "[schema] phase 1 (bootstrap): +")
            (print (int-to-string arena count))
            (print " triples (")
            (print-ms arena (- (now-ms) t0))
            (println ")"))))

      ;; Phase 2: Edge generation — scm-eqc1/1b, scm-eqp1/1b, scm-int, scm-uni
      ;; These read equivalentClass/Property, intersectionOf, unionOf (never produced by scm rules)
      (let ((t0 (now-ms))
            (full-d (make-initial-delta arena graph))
            (mut count 0))
        (for-each (t (scm-eqc1 arena graph full-d))
          (do (set! graph (indexed-graph-add arena graph t))
              (set! count (+ count 1))))
        (for-each (t (scm-eqc1b arena graph full-d))
          (do (set! graph (indexed-graph-add arena graph t))
              (set! count (+ count 1))))
        (for-each (t (scm-eqp1 arena graph full-d))
          (do (set! graph (indexed-graph-add arena graph t))
              (set! count (+ count 1))))
        (for-each (t (scm-eqp1b arena graph full-d))
          (do (set! graph (indexed-graph-add arena graph t))
              (set! count (+ count 1))))
        (for-each (t (scm-int arena graph full-d))
          (do (set! graph (indexed-graph-add arena graph t))
              (set! count (+ count 1))))
        (for-each (t (scm-uni arena graph full-d))
          (do (set! graph (indexed-graph-add arena graph t))
              (set! count (+ count 1))))
        (when verbose
          (do
            (print "[schema] phase 2 (edges): +")
            (print (int-to-string arena count))
            (print " triples (")
            (print-ms arena (- (now-ms) t0))
            (println ")"))))

      ;; Phase 3: Direct transitive closure for subClassOf and subPropertyOf
      (let ((t0 (now-ms))
            (mut count 0))
        (for-each (t (compute-tc arena graph subclass-pred))
          (do (set! graph (indexed-graph-add arena graph t))
              (set! count (+ count 1))))
        (for-each (t (compute-tc arena graph subprop-pred))
          (do (set! graph (indexed-graph-add arena graph t))
              (set! count (+ count 1))))
        (when verbose
          (do
            (print "[schema] phase 3 (TC): +")
            (print (int-to-string arena count))
            (print " triples (")
            (print-ms arena (- (now-ms) t0))
            (println ")"))))

      ;; Phase 3b: Mutual equivalence — derive equivalentClass/Property from mutual sub
      ;; Must run after TC so we have the complete hierarchy
      (let ((t0 (now-ms))
            (full-d (make-initial-delta arena graph))
            (mut count 0))
        (for-each (t (scm-eqc2 arena graph full-d))
          (do (set! graph (indexed-graph-add arena graph t))
              (set! count (+ count 1))))
        (for-each (t (scm-eqp2 arena graph full-d))
          (do (set! graph (indexed-graph-add arena graph t))
              (set! count (+ count 1))))
        (when verbose
          (do
            (print "[schema] phase 3b (mutual-eq): +")
            (print (int-to-string arena count))
            (print " triples (")
            (print-ms arena (- (now-ms) t0))
            (println ")"))))

      ;; Phase 4: Propagation — scm-dom1/2, scm-rng1/2
      ;; These read complete hierarchies + domain/range declarations
      (let ((t0 (now-ms))
            (full-d (make-initial-delta arena graph))
            (mut count 0))
        (for-each (t (scm-dom1 arena graph full-d))
          (do (set! graph (indexed-graph-add arena graph t))
              (set! count (+ count 1))))
        (for-each (t (scm-dom2 arena graph full-d))
          (do (set! graph (indexed-graph-add arena graph t))
              (set! count (+ count 1))))
        (for-each (t (scm-rng1 arena graph full-d))
          (do (set! graph (indexed-graph-add arena graph t))
              (set! count (+ count 1))))
        (for-each (t (scm-rng2 arena graph full-d))
          (do (set! graph (indexed-graph-add arena graph t))
              (set! count (+ count 1))))
        (when verbose
          (do
            (print "[schema] phase 4 (dom/rng): +")
            (print (int-to-string arena count))
            (print " triples (")
            (print-ms arena (- (now-ms) t0))
            (println ")"))))

      ;; Phase 5+6: Structural rules + fixpoint check
      ;; scm-svf1/2, scm-avf1/2, scm-hv may produce new subClassOf edges
      ;; If they do, re-run TC + propagation with incremental delta
      (let ((mut phase-done false)
            (mut phase-iter 0)
            ;; First structural pass uses full-graph delta
            (mut struct-delta (make-initial-delta arena graph)))
        (while (and (not phase-done) (< phase-iter (. config max-iterations)))
          (let ((t0 (now-ms))
                (mut count 0)
                ;; Collect new triples for incremental re-prop delta
                (mut new-delta (make-delta arena 0)))
            (for-each (t (scm-svf1 arena graph struct-delta))
              (do (set! graph (indexed-graph-add arena graph t))
                  (set! new-delta (delta-add arena new-delta t))
                  (set! count (+ count 1))))
            (for-each (t (scm-svf2 arena graph struct-delta))
              (do (set! graph (indexed-graph-add arena graph t))
                  (set! new-delta (delta-add arena new-delta t))
                  (set! count (+ count 1))))
            (for-each (t (scm-avf1 arena graph struct-delta))
              (do (set! graph (indexed-graph-add arena graph t))
                  (set! new-delta (delta-add arena new-delta t))
                  (set! count (+ count 1))))
            (for-each (t (scm-avf2 arena graph struct-delta))
              (do (set! graph (indexed-graph-add arena graph t))
                  (set! new-delta (delta-add arena new-delta t))
                  (set! count (+ count 1))))
            (for-each (t (scm-hv arena graph struct-delta))
              (do (set! graph (indexed-graph-add arena graph t))
                  (set! new-delta (delta-add arena new-delta t))
                  (set! count (+ count 1))))
            (when verbose
              (do
                (print "[schema] phase 5 (structural iter ")
                (print (int-to-string arena phase-iter))
                (print "): +")
                (print (int-to-string arena count))
                (print " triples (")
                (print-ms arena (- (now-ms) t0))
                (println ")")))
            (if (== count 0)
              (set! phase-done true)
              (do
                ;; New subClassOf edges may exist — re-run TC
                (let ((t1 (now-ms))
                      (mut tc-count 0))
                  (for-each (t (compute-tc arena graph subclass-pred))
                    (do (set! graph (indexed-graph-add arena graph t))
                        (set! new-delta (delta-add arena new-delta t))
                        (set! tc-count (+ tc-count 1))))
                  (for-each (t (compute-tc arena graph subprop-pred))
                    (do (set! graph (indexed-graph-add arena graph t))
                        (set! new-delta (delta-add arena new-delta t))
                        (set! tc-count (+ tc-count 1))))
                  (when verbose
                    (do
                      (print "[schema] phase 6 (re-TC): +")
                      (print (int-to-string arena tc-count))
                      (print " triples (")
                      (print-ms arena (- (now-ms) t1))
                      (println ")"))))
                ;; Re-run propagation with incremental delta (only new triples)
                (let ((t2 (now-ms))
                      (mut prop-count 0))
                  (for-each (t (scm-dom1 arena graph new-delta))
                    (do (set! graph (indexed-graph-add arena graph t))
                        (set! prop-count (+ prop-count 1))))
                  (for-each (t (scm-dom2 arena graph new-delta))
                    (do (set! graph (indexed-graph-add arena graph t))
                        (set! prop-count (+ prop-count 1))))
                  (for-each (t (scm-rng1 arena graph new-delta))
                    (do (set! graph (indexed-graph-add arena graph t))
                        (set! prop-count (+ prop-count 1))))
                  (for-each (t (scm-rng2 arena graph new-delta))
                    (do (set! graph (indexed-graph-add arena graph t))
                        (set! prop-count (+ prop-count 1))))
                  (when verbose
                    (do
                      (print "[schema] phase 6 (re-prop): +")
                      (print (int-to-string arena prop-count))
                      (print " triples (")
                      (print-ms arena (- (now-ms) t2))
                      (println ")"))))
                ;; Next structural iteration uses only new triples as delta
                (set! struct-delta new-delta))))
          (set! phase-iter (+ phase-iter 1))))

      ;; Phase 7: Re-run mutual equivalence after structural fixpoint (complete mode only)
      ;; Structural rules produce bnode subClassOf pairs that form mutual relationships;
      ;; scm-eqc2 in phase 3b ran before those existed.
      (when (. config complete)
        (let ((t0 (now-ms))
              (full-d (make-initial-delta arena graph))
              (mut count 0))
          (for-each (t (scm-eqc2 arena graph full-d))
            (do (set! graph (indexed-graph-add arena graph t))
                (set! count (+ count 1))))
          (for-each (t (scm-eqp2 arena graph full-d))
            (do (set! graph (indexed-graph-add arena graph t))
                (set! count (+ count 1))))
          (when verbose
            (do
              (print "[schema] phase 7 (mutual-eq complete): +")
              (print (int-to-string arena count))
              (print " triples (")
              (print-ms arena (- (now-ms) t0))
              (println ")")))))

      (when verbose
        (do
          (print "[schema] done, graph=")
          (print (int-to-string arena (indexed-graph-size graph)))
          (println "")))

      graph))

  ;; ============================================================
  ;; Single Iteration
  ;; ============================================================

  (fn engine-run-iteration ((arena Arena) (state EngineState))
    (@intent "Run one iteration of rule application across all workers")
    (@spec ((Arena EngineState) -> (Result EngineState InconsistencyReport)))
    (@alloc arena)
    (@pre {(. state iteration) >= 0})
    (@post (match $result
             ((ok new-state) {(. new-state iteration) == (+ (. state iteration) 1)})
             ((error _) true)))
    ;; Apply all rules to get new inferred triples
    (match (apply-all-rules arena (. state graph) (. state delta) (. state config))
      ((ok new-delta)
        (let ((mut new-graph (merge-into-graph arena (. state graph) new-delta)))
          ;; eq-ref: add reflexive sameAs directly to graph, not delta
          ;; These are needed for OWL 2 RL completeness but never trigger
          ;; productive inference, so keeping them out of delta avoids cascade.
          (when (not (. (. state config) fast))
            (for-each (t (eq-ref arena new-graph new-delta))
              (set! new-graph (indexed-graph-add arena new-graph t))))
          (ok (record-new EngineState
                (graph new-graph)
                (delta new-delta)
                (iteration (+ (. state iteration) 1))
                (config (. state config))))))
      ((error report)
        (error report))))

  ;; ============================================================
  ;; Rule Application: Dispatch
  ;; ============================================================

  (fn apply-all-rules ((arena Arena) (g IndexedGraph) (delta Delta) (config ReasonerConfig))
    (@intent "Apply all OWL 2 RL rules, dispatching to sequential or parallel path")
    (@spec ((Arena IndexedGraph Delta ReasonerConfig) -> (Result Delta InconsistencyReport)))
    (@alloc arena)
    (@pre {(indexed-graph-size g) >= 0})
    (@post (match $result
             ((ok d) {(. d iteration) == (+ (. delta iteration) 1)})
             ((error _) true)))
    ;; Iteration 0 always runs sequentially to pre-intern all vocabulary
    ;; strings in the global intern pool before concurrent access.
    ;; Single-worker config also uses sequential path.
    (if (or (<= (. config worker-count) 1) (== (. delta iteration) 0))
      (apply-all-rules-sequential arena g delta config)
      (apply-all-rules-parallel arena g delta config)))

  ;; ============================================================
  ;; Rule Application: Sequential Path
  ;; ============================================================

  (fn apply-all-rules-sequential ((arena Arena) (g IndexedGraph) (delta Delta) (config ReasonerConfig))
    (@intent "Apply all OWL 2 RL rules sequentially, return combined delta")
    (@spec ((Arena IndexedGraph Delta ReasonerConfig) -> (Result Delta InconsistencyReport)))
    (@alloc arena)
    (@pre {(indexed-graph-size g) >= 0})
    (@post (match $result
             ((ok d) {(. d iteration) == (+ (. delta iteration) 1)})
             ((error _) true)))
    (let ((next-iter (+ (. delta iteration) 1))
          (mut combined (make-delta arena next-iter))
          (verbose (. config verbose))
          (fast (. config fast)))

      ;; Apply each rule group sequentially with optional timing
      ;; Note: scm rules are handled by schema-materialize (phased pipeline),
      ;; so they are always skipped in the main loop.

      ;; Class axiom rules (subclass propagation)
      (let ((t0 (now-ms)))
        (match (apply-cax-rules arena g delta fast)
          ((ok cax-delta)
            (do
              (when verbose
                (do (print "  cax: ") (print-ms arena (- (now-ms) t0)) (println "")))
              (set! combined (delta-merge arena combined cax-delta))))
          ((error report) (return (error report)))))

      ;; Property rules
      (let ((t0 (now-ms)))
        (match (apply-prp-rules arena g delta fast)
          ((ok prp-delta)
            (do
              (when verbose
                (do (print "  prp: ") (print-ms arena (- (now-ms) t0)) (println "")))
              (set! combined (delta-merge arena combined prp-delta))))
          ((error report) (return (error report)))))

      ;; Equality rules
      (let ((t0 (now-ms)))
        (match (apply-eq-rules arena g delta fast)
          ((ok eq-delta)
            (do
              (when verbose
                (do (print "  eq:  ") (print-ms arena (- (now-ms) t0)) (println "")))
              (set! combined (delta-merge arena combined eq-delta))))
          ((error report) (return (error report)))))

      ;; Class expression rules
      (let ((t0 (now-ms)))
        (match (apply-cls-rules arena g delta fast)
          ((ok cls-delta)
            (do
              (when verbose
                (do (print "  cls: ") (print-ms arena (- (now-ms) t0)) (println "")))
              (set! combined (delta-merge arena combined cls-delta))))
          ((error report) (return (error report)))))

      ;; Each rule already checks (indexed-graph-contains g inferred) before adding,
      ;; and delta-add deduplicates across rules via (set-has seen t).
      (ok combined)))

  ;; ============================================================
  ;; Rule Application: Parallel Path (Fork-Join)
  ;; ============================================================

  (fn apply-all-rules-parallel ((arena Arena) (g IndexedGraph) (delta Delta) (config ReasonerConfig))
    (@intent "Apply all OWL 2 RL rules in parallel using fork-join")
    (@spec ((Arena IndexedGraph Delta ReasonerConfig) -> (Result Delta InconsistencyReport)))
    (@alloc arena)
    (@pre {(indexed-graph-size g) >= 0})
    (@pre {(. config worker-count) > 1})
    (@post (match $result
             ((ok d) {(. d iteration) == (+ (. delta iteration) 1)})
             ((error _) true)))
    (let ((next-iter (+ (. delta iteration) 1))
          (fast (. config fast))
          (result-chan (chan-buffered WorkerMessage arena (. config channel-buffer)))
          ;; Allocate coordinator-owned per-worker arenas so data survives until collect
          ;; SCM arenas removed: schema rules handled by schema-materialize
          (arena-cax-infer  (arena-new 1048576))
          (arena-cax-check  (arena-new 1048576))
          (arena-prp-char   (arena-new 1048576))
          (arena-prp-chain  (arena-new 1048576))
          (arena-prp-check  (arena-new 1048576))
          (arena-eq-infer   (arena-new 1048576))
          (arena-eq-check   (arena-new (if fast 64 1048576)))
          (arena-cls-set    (arena-new 1048576))
          (arena-cls-ind    (arena-new 1048576)))

      ;; Spawn sub-workers (count varies with fast mode)
      (let ((workers (spawn-rule-workers arena g delta result-chan
                                         arena-cax-infer arena-cax-check
                                         arena-prp-char arena-prp-chain arena-prp-check
                                         arena-eq-infer arena-eq-check
                                         arena-cls-set arena-cls-ind
                                         (. config verbose) fast)))

        ;; Collect results from all workers
        (let ((result (collect-worker-results arena result-chan workers next-iter)))

          ;; Only free worker arenas when no inconsistency was found.
          ;; InconsistencyReport witnesses live in worker arenas — freeing
          ;; them before the report is consumed would cause use-after-free.
          (match result
            ((ok _)
              (do
                (arena-free arena-cax-infer)
                (arena-free arena-cax-check)
                (arena-free arena-prp-char)
                (arena-free arena-prp-chain)
                (arena-free arena-prp-check)
                (arena-free arena-eq-infer)
                (arena-free arena-eq-check)
                (arena-free arena-cls-set)
                (arena-free arena-cls-ind)))
            ((error _) (do)))

          result))))

  ;; ============================================================
  ;; Graph Merging
  ;; ============================================================

  (fn merge-into-graph ((arena Arena) (g IndexedGraph) (d Delta))
    (@intent "Add all triples from delta into graph")
    (@spec ((Arena IndexedGraph Delta) -> IndexedGraph))
    (@alloc arena)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(indexed-graph-size $result) >= (indexed-graph-size g)})
    (@post {(indexed-graph-size $result) <= (+ (indexed-graph-size g) (list-len (. d triples)))})
    (let ((mut result g))
      (for-each (t (. d triples))
        (set! result (indexed-graph-add arena result t)))
      result))

  ;; ============================================================
  ;; Parallel Worker Management
  ;; ============================================================

  (fn spawn-rule-workers ((arena Arena) (g IndexedGraph) (delta Delta)
                          (result-chan (Ptr (Chan WorkerMessage)))
                          (arena-cax-infer Arena) (arena-cax-check Arena)
                          (arena-prp-char Arena) (arena-prp-chain Arena) (arena-prp-check Arena)
                          (arena-eq-infer Arena) (arena-eq-check Arena)
                          (arena-cls-set Arena) (arena-cls-ind Arena)
                          (verbose Bool) (fast Bool))
    (@intent "Spawn sub-worker threads, each handling a semantic subset of rules")
    (@spec ((Arena IndexedGraph Delta (Ptr (Chan WorkerMessage))
             Arena Arena Arena Arena Arena Arena Arena Arena Arena Bool Bool)
            -> (List (Ptr (Thread Unit)))))
    (@alloc arena)
    (let ((mut workers (list-new arena (Ptr (Thread Unit))))
          (next-iter (+ (. delta iteration) 1)))

      ;; ---- SCM sub-workers skipped: handled by schema-materialize ----

      ;; ---- CAX sub-workers ----

      ;; cax-infer: cax-sco, cax-eqc1, cax-eqc2 (always runs)
      (list-push workers
        (spawn arena (fn ()
          (let ((t0 (now-ms))
                (mut result (make-delta arena-cax-infer next-iter)))
            (for-each (t (cax-sco arena-cax-infer g delta))
              (set! result (delta-add arena-cax-infer result t)))
            (for-each (t (cax-eqc1 arena-cax-infer g delta))
              (set! result (delta-add arena-cax-infer result t)))
            (for-each (t (cax-eqc2 arena-cax-infer g delta))
              (set! result (delta-add arena-cax-infer result t)))
            (when verbose
              (do (print "  cax-infer: ") (print-ms arena-cax-infer (- (now-ms) t0)) (println "")))
            (send result-chan (union-new WorkerMessage msg-delta result))
            (send result-chan (union-new WorkerMessage msg-done unit))))))

      ;; cax-check: cax-dw, cax-adc (always runs)
      (list-push workers
        (spawn arena (fn ()
          (let ((t0 (now-ms)))
            (match (cax-dw arena-cax-check g delta)
              ((some report) (do (send result-chan (union-new WorkerMessage msg-inconsistent report)) (do)))
              ((none)
                (match (cax-adc arena-cax-check g delta)
                  ((some report) (do (send result-chan (union-new WorkerMessage msg-inconsistent report)) (do)))
                  ((none) (do)))))
            (when verbose
              (do (print "  cax-check: ") (print-ms arena-cax-check (- (now-ms) t0)) (println "")))
            (send result-chan (union-new WorkerMessage msg-done unit))))))

      ;; ---- PRP sub-workers ----

      ;; prp-char: prp-dom, prp-rng, prp-fp, prp-ifp, prp-symp, prp-trp (always runs)
      (list-push workers
        (spawn arena (fn ()
          (let ((t0 (now-ms))
                (mut result (make-delta arena-prp-char next-iter)))
            (for-each (t (prp-dom arena-prp-char g delta))
              (set! result (delta-add arena-prp-char result t)))
            (for-each (t (prp-rng arena-prp-char g delta))
              (set! result (delta-add arena-prp-char result t)))
            (for-each (t (prp-fp arena-prp-char g delta))
              (set! result (delta-add arena-prp-char result t)))
            (for-each (t (prp-ifp arena-prp-char g delta))
              (set! result (delta-add arena-prp-char result t)))
            (for-each (t (prp-symp arena-prp-char g delta))
              (set! result (delta-add arena-prp-char result t)))
            (for-each (t (prp-trp arena-prp-char g delta))
              (set! result (delta-add arena-prp-char result t)))
            (when verbose
              (do (print "  prp-char: ") (print-ms arena-prp-char (- (now-ms) t0)) (println "")))
            (send result-chan (union-new WorkerMessage msg-delta result))
            (send result-chan (union-new WorkerMessage msg-done unit))))))

      ;; prp-chain: prp-spo1, prp-spo2, prp-eqp1, prp-eqp2, prp-inv1, prp-inv2, prp-key (always runs)
      (list-push workers
        (spawn arena (fn ()
          (let ((t0 (now-ms))
                (mut result (make-delta arena-prp-chain next-iter)))
            (for-each (t (prp-spo1 arena-prp-chain g delta))
              (set! result (delta-add arena-prp-chain result t)))
            (for-each (t (prp-spo2 arena-prp-chain g delta))
              (set! result (delta-add arena-prp-chain result t)))
            (for-each (t (prp-eqp1 arena-prp-chain g delta))
              (set! result (delta-add arena-prp-chain result t)))
            (for-each (t (prp-eqp2 arena-prp-chain g delta))
              (set! result (delta-add arena-prp-chain result t)))
            (for-each (t (prp-inv1 arena-prp-chain g delta))
              (set! result (delta-add arena-prp-chain result t)))
            (for-each (t (prp-inv2 arena-prp-chain g delta))
              (set! result (delta-add arena-prp-chain result t)))
            (for-each (t (prp-key arena-prp-chain g delta))
              (set! result (delta-add arena-prp-chain result t)))
            (when verbose
              (do (print "  prp-chain: ") (print-ms arena-prp-chain (- (now-ms) t0)) (println "")))
            (send result-chan (union-new WorkerMessage msg-delta result))
            (send result-chan (union-new WorkerMessage msg-done unit))))))

      ;; prp-check: prp-asyp, prp-irp, prp-pdw, prp-adp, prp-npa1, prp-npa2 (always runs)
      (list-push workers
        (spawn arena (fn ()
          (let ((t0 (now-ms)))
            (match (prp-asyp arena-prp-check g delta)
              ((some report) (do (send result-chan (union-new WorkerMessage msg-inconsistent report)) (do)))
              ((none)
                (match (prp-irp arena-prp-check g delta)
                  ((some report) (do (send result-chan (union-new WorkerMessage msg-inconsistent report)) (do)))
                  ((none)
                    (match (prp-pdw arena-prp-check g delta)
                      ((some report) (do (send result-chan (union-new WorkerMessage msg-inconsistent report)) (do)))
                      ((none)
                        (match (prp-adp arena-prp-check g delta)
                          ((some report) (do (send result-chan (union-new WorkerMessage msg-inconsistent report)) (do)))
                          ((none)
                            (match (prp-npa1 arena-prp-check g delta)
                              ((some report) (do (send result-chan (union-new WorkerMessage msg-inconsistent report)) (do)))
                              ((none)
                                (match (prp-npa2 arena-prp-check g delta)
                                  ((some report) (do (send result-chan (union-new WorkerMessage msg-inconsistent report)) (do)))
                                  ((none) (do)))))))))))))
            (when verbose
              (do (print "  prp-check: ") (print-ms arena-prp-check (- (now-ms) t0)) (println "")))
            (send result-chan (union-new WorkerMessage msg-done unit))))))

      ;; ---- EQ sub-workers ----

      ;; eq-infer: eq-sym, eq-trans, eq-rep-s, eq-rep-p, eq-rep-o (always runs)
      ;; Note: eq-ref runs post-merge in engine-run-iteration (graph-only, not delta)
      (list-push workers
        (spawn arena (fn ()
          (let ((t0 (now-ms))
                (mut result (make-delta arena-eq-infer next-iter)))
            (for-each (t (eq-sym arena-eq-infer g delta))
              (set! result (delta-add arena-eq-infer result t)))
            (for-each (t (eq-trans arena-eq-infer g delta))
              (set! result (delta-add arena-eq-infer result t)))
            (for-each (t (eq-rep-s arena-eq-infer g delta))
              (set! result (delta-add arena-eq-infer result t)))
            (for-each (t (eq-rep-p arena-eq-infer g delta))
              (set! result (delta-add arena-eq-infer result t)))
            (for-each (t (eq-rep-o arena-eq-infer g delta))
              (set! result (delta-add arena-eq-infer result t)))
            (when verbose
              (do (print "  eq-infer: ") (print-ms arena-eq-infer (- (now-ms) t0)) (println "")))
            (send result-chan (union-new WorkerMessage msg-delta result))
            (send result-chan (union-new WorkerMessage msg-done unit))))))

      ;; eq-check: eq-diff1, eq-diff2, eq-diff3 (skipped in fast mode)
      (when (not fast)
        (list-push workers
          (spawn arena (fn ()
            (let ((t0 (now-ms)))
              (match (eq-diff1 arena-eq-check g delta)
                ((some report) (do (send result-chan (union-new WorkerMessage msg-inconsistent report)) (do)))
                ((none)
                  (match (eq-diff2 arena-eq-check g delta)
                    ((some report) (do (send result-chan (union-new WorkerMessage msg-inconsistent report)) (do)))
                    ((none)
                      (match (eq-diff3 arena-eq-check g delta)
                        ((some report) (do (send result-chan (union-new WorkerMessage msg-inconsistent report)) (do)))
                        ((none) (do)))))))
              (when verbose
                (do (print "  eq-check: ") (print-ms arena-eq-check (- (now-ms) t0)) (println "")))
              (send result-chan (union-new WorkerMessage msg-done unit)))))))

      ;; ---- CLS sub-workers ----

      ;; cls-set: cls-int1, cls-int2, cls-uni, cls-svf1, cls-svf2, cls-avf (always runs)
      (list-push workers
        (spawn arena (fn ()
          (let ((t0 (now-ms))
                (mut result (make-delta arena-cls-set next-iter)))
            (for-each (t (cls-int1 arena-cls-set g delta))
              (set! result (delta-add arena-cls-set result t)))
            (for-each (t (cls-int2 arena-cls-set g delta))
              (set! result (delta-add arena-cls-set result t)))
            (for-each (t (cls-uni arena-cls-set g delta))
              (set! result (delta-add arena-cls-set result t)))
            (for-each (t (cls-svf1 arena-cls-set g delta))
              (set! result (delta-add arena-cls-set result t)))
            (for-each (t (cls-svf2 arena-cls-set g delta))
              (set! result (delta-add arena-cls-set result t)))
            (for-each (t (cls-avf arena-cls-set g delta))
              (set! result (delta-add arena-cls-set result t)))
            (when verbose
              (do (print "  cls-set: ") (print-ms arena-cls-set (- (now-ms) t0)) (println "")))
            (send result-chan (union-new WorkerMessage msg-delta result))
            (send result-chan (union-new WorkerMessage msg-done unit))))))

      ;; cls-ind: cls-hv1, cls-hv2, cls-oo + conditionally cls-maxc1/2, cls-nothing2, cls-com
      (list-push workers
        (spawn arena (fn ()
          (let ((t0 (now-ms))
                (mut result (make-delta arena-cls-ind next-iter)))
            (for-each (t (cls-hv1 arena-cls-ind g delta))
              (set! result (delta-add arena-cls-ind result t)))
            (for-each (t (cls-hv2 arena-cls-ind g delta))
              (set! result (delta-add arena-cls-ind result t)))
            ;; Cardinality rules (skipped in fast mode)
            (when (not fast)
              (do
                (match (cls-maxc1 arena-cls-ind g delta)
                  ((some report) (do (send result-chan (union-new WorkerMessage msg-inconsistent report)) (do)))
                  ((none) (do)))
                (for-each (t (cls-maxc2 arena-cls-ind g delta))
                  (set! result (delta-add arena-cls-ind result t)))
                ;; Qualified cardinality checks
                (match (cls-maxqc1 arena-cls-ind g delta)
                  ((some report) (do (send result-chan (union-new WorkerMessage msg-inconsistent report)) (do)))
                  ((none)
                    (match (cls-maxqc2 arena-cls-ind g delta)
                      ((some report) (do (send result-chan (union-new WorkerMessage msg-inconsistent report)) (do)))
                      ((none) (do)))))
                ;; Qualified cardinality inferences
                (for-each (t (cls-maxqc3 arena-cls-ind g delta))
                  (set! result (delta-add arena-cls-ind result t)))
                (for-each (t (cls-maxqc4 arena-cls-ind g delta))
                  (set! result (delta-add arena-cls-ind result t)))))
            (for-each (t (cls-oo arena-cls-ind g delta))
              (set! result (delta-add arena-cls-ind result t)))
            ;; cls-nothing2 and cls-com are check rules (always run)
            (match (cls-nothing2 arena-cls-ind g delta)
              ((some report) (do (send result-chan (union-new WorkerMessage msg-inconsistent report)) (do)))
              ((none)
                (match (cls-com arena-cls-ind g delta)
                  ((some report) (do (send result-chan (union-new WorkerMessage msg-inconsistent report)) (do)))
                  ((none) (do)))))
            (when verbose
              (do (print "  cls-ind: ") (print-ms arena-cls-ind (- (now-ms) t0)) (println "")))
            (send result-chan (union-new WorkerMessage msg-delta result))
            (send result-chan (union-new WorkerMessage msg-done unit))))))

      workers))

  (fn collect-worker-results ((arena Arena) (result-chan (Ptr (Chan WorkerMessage)))
                              (workers (List (Ptr (Thread Unit))))
                              (next-iter (Int 0 ..)))
    (@intent "Collect all worker results and merge deltas into combined delta")
    (@spec ((Arena (Ptr (Chan WorkerMessage)) (List (Ptr (Thread Unit))) (Int 0 ..))
            -> (Result Delta InconsistencyReport)))
    (@alloc arena)
    (@pre {(list-len workers) >= 1})
    (@pre {next-iter >= 1})
    (@post (match $result
             ((ok d) {(. d iteration) == next-iter})
             ((error _) true)))
    ;; Collect results from channel before joining
    (let ((mut combined (make-delta arena next-iter))
          (mut inconsistency (Option InconsistencyReport) (none))
          (mut done-count 0)
          (expected (list-len workers)))
      ;; Receive all messages until we get a msg-done from each worker
      (while (< done-count expected)
        (match (recv result-chan)
          ((ok msg)
            (match msg
              ((msg-delta d)
                (set! combined (delta-merge arena combined d)))
              ((msg-inconsistent r)
                (set! inconsistency (some r)))
              ((msg-done _)
                (set! done-count (+ done-count 1)))))
          ((error _)
            ;; Channel error, stop receiving
            (set! done-count expected))))
      ;; Join all workers to ensure they've completed
      (for-each (w workers)
        (join w))
      ;; Return inconsistency if found, otherwise merged delta
      (match inconsistency
        ((some r) (error r))
        ((none) (ok combined))))))
