;; ============================================================
;; OWL 2 RL Table 5: Property Axiom Rules (prp-*)
;;
;; These rules handle property characteristics, domain/range
;; inference, and property chains.
;;
;; Reference: https://www.w3.org/TR/owl2-profiles/#OWL_2_RL
;; ============================================================

(module prp
  (@doc "OWL 2 RL property axiom rules with formally verified contracts")

  (import rdf (Term Triple term-eq triple-eq make-iri make-triple make-literal
               triple-subject triple-predicate triple-object))
  (import index (IndexedGraph indexed-graph-match indexed-graph-for-each indexed-graph-contains indexed-graph-size
                 indexed-graph-create indexed-graph-add))
  (import vocab (RDF_TYPE RDFS_DOMAIN RDFS_RANGE RDFS_SUBPROPERTY_OF
                 RDFS_LABEL RDFS_COMMENT RDFS_SEE_ALSO RDFS_IS_DEFINED_BY
                 OWL_SAME_AS OWL_DIFFERENT_FROM OWL_EQUIVALENT_PROPERTY
                 OWL_FUNCTIONAL_PROPERTY OWL_INVERSE_FUNCTIONAL_PROPERTY
                 OWL_SYMMETRIC_PROPERTY OWL_ASYMMETRIC_PROPERTY
                 OWL_TRANSITIVE_PROPERTY OWL_IRREFLEXIVE_PROPERTY
                 OWL_INVERSE_OF OWL_PROPERTY_DISJOINT_WITH
                 OWL_PROPERTY_CHAIN_AXIOM OWL_HAS_KEY
                 OWL_NEGATIVE_PROPERTY_ASSERTION OWL_SOURCE_INDIVIDUAL
                 OWL_ASSERTION_PROPERTY OWL_TARGET_INDIVIDUAL OWL_TARGET_VALUE
                 OWL_ALL_DISJOINT_PROPERTIES OWL_MEMBERS OWL_THING
                 OWL_ANNOTATION_PROPERTY OWL_VERSION_IRI
                 OWL_DEPRECATED OWL_VERSION_INFO OWL_PRIOR_VERSION
                 OWL_BACKWARD_COMPATIBLE_WITH OWL_INCOMPATIBLE_WITH))
  (import list (rdf-list-elements rdf-list-elements-indexed))
  (import types (Delta InconsistencyReport make-delta delta-add all-triples-have-predicate))

  (export
    apply-prp-rules
    prp-dom
    prp-rng
    prp-fp
    prp-ifp
    prp-symp
    prp-asyp
    prp-trp
    prp-irp
    prp-spo1
    prp-spo2
    prp-inv1
    prp-inv2
    prp-eqp1
    prp-eqp2
    prp-pdw
    prp-adp
    prp-key
    prp-npa1
    prp-npa2
    prp-ap)

  ;; ============================================================
  ;; Test Fixture URIs (for @example annotations)
  ;; ============================================================

  (const EX_ALICE String "http://example.org/alice")
  (const EX_ALICIA String "http://example.org/alicia")
  (const EX_BOB String "http://example.org/bob")
  (const EX_MARY String "http://example.org/mary")
  (const EX_MARIA String "http://example.org/maria")
  (const EX_A String "http://example.org/a")
  (const EX_B String "http://example.org/b")
  (const EX_C String "http://example.org/c")
  (const EX_PERSON String "http://example.org/Person")
  (const EX_HAS_CHILD String "http://example.org/hasChild")
  (const EX_HAS_PARENT String "http://example.org/hasParent")
  (const EX_HAS_FATHER String "http://example.org/hasFather")
  (const EX_HAS_MOTHER String "http://example.org/hasMother")
  (const EX_ANCESTOR String "http://example.org/ancestor")
  (const EX_KNOWS String "http://example.org/knows")
  (const EX_LIKES String "http://example.org/likes")
  (const EX_HATES String "http://example.org/hates")
  (const EX_SSN String "http://example.org/ssn")

  ;; ============================================================
  ;; Test Fixture Builders
  ;; ============================================================

  ;; Graph with (hasChild domain Person), (alice hasChild bob)
  (fn fixture-g-domain ((arena Arena))
    (@intent "Create test graph: domain inference scenario")
    (@spec ((Arena) -> IndexedGraph))
    (let ((mut g (indexed-graph-create arena))
          (domain-pred (make-iri arena RDFS_DOMAIN))
          (has-child (make-iri arena EX_HAS_CHILD))
          (person (make-iri arena EX_PERSON))
          (alice (make-iri arena EX_ALICE))
          (bob (make-iri arena EX_BOB)))
      (set! g (indexed-graph-add arena g (make-triple arena has-child domain-pred person)))
      (set! g (indexed-graph-add arena g (make-triple arena alice has-child bob)))
      g))

  ;; Graph with (hasChild range Person), (alice hasChild bob)
  (fn fixture-g-range ((arena Arena))
    (@intent "Create test graph: range inference scenario")
    (@spec ((Arena) -> IndexedGraph))
    (let ((mut g (indexed-graph-create arena))
          (range-pred (make-iri arena RDFS_RANGE))
          (has-child (make-iri arena EX_HAS_CHILD))
          (person (make-iri arena EX_PERSON))
          (alice (make-iri arena EX_ALICE))
          (bob (make-iri arena EX_BOB)))
      (set! g (indexed-graph-add arena g (make-triple arena has-child range-pred person)))
      (set! g (indexed-graph-add arena g (make-triple arena alice has-child bob)))
      g))

  ;; Graph with functional property: (hasMother type FunctionalProperty)
  (fn fixture-g-functional ((arena Arena))
    (@intent "Create test graph: functional property scenario")
    (@spec ((Arena) -> IndexedGraph))
    (let ((mut g (indexed-graph-create arena))
          (type-pred (make-iri arena RDF_TYPE))
          (fp-type (make-iri arena OWL_FUNCTIONAL_PROPERTY))
          (has-mother (make-iri arena EX_HAS_MOTHER))
          (alice (make-iri arena EX_ALICE))
          (mary (make-iri arena EX_MARY))
          (maria (make-iri arena EX_MARIA)))
      (set! g (indexed-graph-add arena g (make-triple arena has-mother type-pred fp-type)))
      (set! g (indexed-graph-add arena g (make-triple arena alice has-mother mary)))
      (set! g (indexed-graph-add arena g (make-triple arena alice has-mother maria)))
      g))

  ;; Graph with inverse functional property
  (fn fixture-g-ifp ((arena Arena))
    (@intent "Create test graph: inverse functional property scenario")
    (@spec ((Arena) -> IndexedGraph))
    (let ((mut g (indexed-graph-create arena))
          (type-pred (make-iri arena RDF_TYPE))
          (ifp-type (make-iri arena OWL_INVERSE_FUNCTIONAL_PROPERTY))
          (ssn (make-iri arena EX_SSN))
          (alice (make-iri arena EX_ALICE))
          (alicia (make-iri arena EX_ALICIA))
          (ssn-val (make-literal arena "123" (none) (none))))
      (set! g (indexed-graph-add arena g (make-triple arena ssn type-pred ifp-type)))
      (set! g (indexed-graph-add arena g (make-triple arena alice ssn ssn-val)))
      (set! g (indexed-graph-add arena g (make-triple arena alicia ssn ssn-val)))
      g))

  ;; Graph with symmetric property
  (fn fixture-g-symmetric ((arena Arena))
    (@intent "Create test graph: symmetric property scenario")
    (@spec ((Arena) -> IndexedGraph))
    (let ((mut g (indexed-graph-create arena))
          (type-pred (make-iri arena RDF_TYPE))
          (sym-type (make-iri arena OWL_SYMMETRIC_PROPERTY))
          (knows (make-iri arena EX_KNOWS))
          (alice (make-iri arena EX_ALICE))
          (bob (make-iri arena EX_BOB)))
      (set! g (indexed-graph-add arena g (make-triple arena knows type-pred sym-type)))
      (set! g (indexed-graph-add arena g (make-triple arena alice knows bob)))
      g))

  ;; Graph with asymmetric property violation
  (fn fixture-g-asym-violation ((arena Arena))
    (@intent "Create test graph: asymmetric property violation")
    (@spec ((Arena) -> IndexedGraph))
    (let ((mut g (indexed-graph-create arena))
          (type-pred (make-iri arena RDF_TYPE))
          (asym-type (make-iri arena OWL_ASYMMETRIC_PROPERTY))
          (has-parent (make-iri arena EX_HAS_PARENT))
          (alice (make-iri arena EX_ALICE))
          (bob (make-iri arena EX_BOB)))
      (set! g (indexed-graph-add arena g (make-triple arena has-parent type-pred asym-type)))
      (set! g (indexed-graph-add arena g (make-triple arena alice has-parent bob)))
      (set! g (indexed-graph-add arena g (make-triple arena bob has-parent alice)))
      g))

  ;; Graph with transitive property
  (fn fixture-g-transitive ((arena Arena))
    (@intent "Create test graph: transitive property scenario")
    (@spec ((Arena) -> IndexedGraph))
    (let ((mut g (indexed-graph-create arena))
          (type-pred (make-iri arena RDF_TYPE))
          (trans-type (make-iri arena OWL_TRANSITIVE_PROPERTY))
          (ancestor (make-iri arena EX_ANCESTOR))
          (a (make-iri arena EX_A))
          (b (make-iri arena EX_B))
          (c (make-iri arena EX_C)))
      (set! g (indexed-graph-add arena g (make-triple arena ancestor type-pred trans-type)))
      (set! g (indexed-graph-add arena g (make-triple arena a ancestor b)))
      (set! g (indexed-graph-add arena g (make-triple arena b ancestor c)))
      g))

  ;; Graph with irreflexive property violation
  (fn fixture-g-irp-violation ((arena Arena))
    (@intent "Create test graph: irreflexive property violation")
    (@spec ((Arena) -> IndexedGraph))
    (let ((mut g (indexed-graph-create arena))
          (type-pred (make-iri arena RDF_TYPE))
          (irp-type (make-iri arena OWL_IRREFLEXIVE_PROPERTY))
          (has-parent (make-iri arena EX_HAS_PARENT))
          (alice (make-iri arena EX_ALICE)))
      (set! g (indexed-graph-add arena g (make-triple arena has-parent type-pred irp-type)))
      (set! g (indexed-graph-add arena g (make-triple arena alice has-parent alice)))
      g))

  ;; Graph with subproperty
  (fn fixture-g-subprop ((arena Arena))
    (@intent "Create test graph: subproperty inference scenario")
    (@spec ((Arena) -> IndexedGraph))
    (let ((mut g (indexed-graph-create arena))
          (subprop-pred (make-iri arena RDFS_SUBPROPERTY_OF))
          (has-father (make-iri arena EX_HAS_FATHER))
          (has-parent (make-iri arena EX_HAS_PARENT))
          (alice (make-iri arena EX_ALICE))
          (bob (make-iri arena EX_BOB)))
      (set! g (indexed-graph-add arena g (make-triple arena has-father subprop-pred has-parent)))
      (set! g (indexed-graph-add arena g (make-triple arena alice has-father bob)))
      g))

  ;; Graph with inverse property axiom only (no usage triples - those go in delta)
  (fn fixture-g-inverse ((arena Arena))
    (@intent "Create test graph: inverse property axiom only")
    (@spec ((Arena) -> IndexedGraph))
    (let ((mut g (indexed-graph-create arena))
          (inverse-pred (make-iri arena OWL_INVERSE_OF))
          (has-parent (make-iri arena EX_HAS_PARENT))
          (has-child (make-iri arena EX_HAS_CHILD)))
      (set! g (indexed-graph-add arena g (make-triple arena has-parent inverse-pred has-child)))
      g))

  ;; Graph with property disjointness violation
  (fn fixture-g-pdw-violation ((arena Arena))
    (@intent "Create test graph: property disjoint violation")
    (@spec ((Arena) -> IndexedGraph))
    (let ((mut g (indexed-graph-create arena))
          (pdw-pred (make-iri arena OWL_PROPERTY_DISJOINT_WITH))
          (likes (make-iri arena EX_LIKES))
          (hates (make-iri arena EX_HATES))
          (alice (make-iri arena EX_ALICE))
          (bob (make-iri arena EX_BOB)))
      (set! g (indexed-graph-add arena g (make-triple arena likes pdw-pred hates)))
      (set! g (indexed-graph-add arena g (make-triple arena alice likes bob)))
      (set! g (indexed-graph-add arena g (make-triple arena alice hates bob)))
      g))

  ;; Delta with property usage for domain/range tests
  (fn fixture-delta-usage ((arena Arena))
    (@intent "Create delta: alice hasChild bob")
    (@spec ((Arena) -> Delta))
    (let ((mut d (make-delta arena 0))
          (has-child (make-iri arena EX_HAS_CHILD))
          (alice (make-iri arena EX_ALICE))
          (bob (make-iri arena EX_BOB)))
      (set! d (delta-add arena d (make-triple arena alice has-child bob)))
      d))

  ;; Empty delta
  (fn fixture-delta-empty ((arena Arena))
    (@intent "Create empty delta")
    (@spec ((Arena) -> Delta))
    (make-delta arena 0))

  ;; Delta for functional property test: (alice hasMother mary)
  (fn fixture-delta-functional ((arena Arena))
    (@intent "Create delta for functional property test")
    (@spec ((Arena) -> Delta))
    (let ((mut d (make-delta arena 0))
          (has-mother (make-iri arena EX_HAS_MOTHER))
          (alice (make-iri arena EX_ALICE))
          (mary (make-iri arena EX_MARY)))
      (set! d (delta-add arena d (make-triple arena alice has-mother mary)))
      d))

  ;; Delta for inverse functional property test: (alice ssn "123")
  (fn fixture-delta-ifp ((arena Arena))
    (@intent "Create delta for inverse functional property test")
    (@spec ((Arena) -> Delta))
    (let ((mut d (make-delta arena 0))
          (ssn (make-iri arena EX_SSN))
          (alice (make-iri arena EX_ALICE))
          (ssn-val (make-literal arena "123" (none) (none))))
      (set! d (delta-add arena d (make-triple arena alice ssn ssn-val)))
      d))

  ;; Delta for symmetric property test: (alice knows bob)
  (fn fixture-delta-symmetric ((arena Arena))
    (@intent "Create delta for symmetric property test")
    (@spec ((Arena) -> Delta))
    (let ((mut d (make-delta arena 0))
          (knows (make-iri arena EX_KNOWS))
          (alice (make-iri arena EX_ALICE))
          (bob (make-iri arena EX_BOB)))
      (set! d (delta-add arena d (make-triple arena alice knows bob)))
      d))

  ;; Delta for asymmetric property test: (alice hasParent bob)
  (fn fixture-delta-asymmetric ((arena Arena))
    (@intent "Create delta for asymmetric property test")
    (@spec ((Arena) -> Delta))
    (let ((mut d (make-delta arena 0))
          (has-parent (make-iri arena EX_HAS_PARENT))
          (alice (make-iri arena EX_ALICE))
          (bob (make-iri arena EX_BOB)))
      (set! d (delta-add arena d (make-triple arena alice has-parent bob)))
      d))

  ;; Delta for transitive property test: (a ancestor b)
  (fn fixture-delta-transitive ((arena Arena))
    (@intent "Create delta for transitive property test")
    (@spec ((Arena) -> Delta))
    (let ((mut d (make-delta arena 0))
          (ancestor (make-iri arena EX_ANCESTOR))
          (a (make-iri arena EX_A))
          (b (make-iri arena EX_B)))
      (set! d (delta-add arena d (make-triple arena a ancestor b)))
      d))

  ;; Delta for irreflexive property test: (alice hasParent alice)
  (fn fixture-delta-irreflexive ((arena Arena))
    (@intent "Create delta for irreflexive property test")
    (@spec ((Arena) -> Delta))
    (let ((mut d (make-delta arena 0))
          (has-parent (make-iri arena EX_HAS_PARENT))
          (alice (make-iri arena EX_ALICE)))
      (set! d (delta-add arena d (make-triple arena alice has-parent alice)))
      d))

  ;; Delta for subproperty test: (alice hasFather bob)
  (fn fixture-delta-subprop ((arena Arena))
    (@intent "Create delta for subproperty test")
    (@spec ((Arena) -> Delta))
    (let ((mut d (make-delta arena 0))
          (has-father (make-iri arena EX_HAS_FATHER))
          (alice (make-iri arena EX_ALICE))
          (bob (make-iri arena EX_BOB)))
      (set! d (delta-add arena d (make-triple arena alice has-father bob)))
      d))

  ;; Delta for inverse property test 1: (alice hasParent bob)
  (fn fixture-delta-inverse1 ((arena Arena))
    (@intent "Create delta for inverse property test (forward)")
    (@spec ((Arena) -> Delta))
    (let ((mut d (make-delta arena 0))
          (has-parent (make-iri arena EX_HAS_PARENT))
          (alice (make-iri arena EX_ALICE))
          (bob (make-iri arena EX_BOB)))
      (set! d (delta-add arena d (make-triple arena alice has-parent bob)))
      d))

  ;; Delta for inverse property test 2: (bob hasChild alice)
  (fn fixture-delta-inverse2 ((arena Arena))
    (@intent "Create delta for inverse property test (backward)")
    (@spec ((Arena) -> Delta))
    (let ((mut d (make-delta arena 0))
          (has-child (make-iri arena EX_HAS_CHILD))
          (alice (make-iri arena EX_ALICE))
          (bob (make-iri arena EX_BOB)))
      (set! d (delta-add arena d (make-triple arena bob has-child alice)))
      d))

  ;; Delta for property disjointness test: (alice likes bob)
  (fn fixture-delta-pdw ((arena Arena))
    (@intent "Create delta for property disjointness test")
    (@spec ((Arena) -> Delta))
    (let ((mut d (make-delta arena 0))
          (likes (make-iri arena EX_LIKES))
          (alice (make-iri arena EX_ALICE))
          (bob (make-iri arena EX_BOB)))
      (set! d (delta-add arena d (make-triple arena alice likes bob)))
      d))

  ;; ============================================================
  ;; Rule Dispatcher
  ;; ============================================================

  (fn apply-prp-rules ((arena Arena) (g IndexedGraph) (delta Delta) (fast Bool) (validate Bool))
    (@intent "Apply all property axiom rules (Table 5)")
    (@spec ((Arena IndexedGraph Delta Bool Bool) -> (Result Delta InconsistencyReport)))
    (@alloc arena)
    (@pre {(indexed-graph-size g) >= 0})
    (@post (match $result
             ((ok d) {(. d iteration) == (+ (. delta iteration) 1)})
             ((error _) true)))
    (let ((next-iter (+ (. delta iteration) 1))
          (mut result (make-delta arena next-iter)))

      ;; Domain/range rules
      (for-each (t (prp-dom arena g delta))
        (set! result (delta-add arena result t)))
      (for-each (t (prp-rng arena g delta))
        (set! result (delta-add arena result t)))

      ;; Functional property rules
      (for-each (t (prp-fp arena g delta))
        (set! result (delta-add arena result t)))
      (for-each (t (prp-ifp arena g delta))
        (set! result (delta-add arena result t)))

      ;; Property characteristics
      (for-each (t (prp-symp arena g delta))
        (set! result (delta-add arena result t)))
      (for-each (t (prp-trp arena g delta))
        (set! result (delta-add arena result t)))

      ;; Inconsistency checks (skip in validate mode — post-fixpoint scan handles these)
      (when (not validate)
        (do
          (match (prp-asyp arena g delta)
            ((some report) (return (error report)))
            ((none) (do)))
          (match (prp-irp arena g delta)
            ((some report) (return (error report)))
            ((none) (do)))
          (match (prp-pdw arena g delta)
            ((some report) (return (error report)))
            ((none) (do)))
          (match (prp-adp arena g delta)
            ((some report) (return (error report)))
            ((none) (do)))
          (match (prp-npa1 arena g delta)
            ((some report) (return (error report)))
            ((none) (do)))
          (match (prp-npa2 arena g delta)
            ((some report) (return (error report)))
            ((none) (do)))))

      ;; Subproperty and equivalence
      (for-each (t (prp-spo1 arena g delta))
        (set! result (delta-add arena result t)))
      (for-each (t (prp-eqp1 arena g delta))
        (set! result (delta-add arena result t)))
      (for-each (t (prp-eqp2 arena g delta))
        (set! result (delta-add arena result t)))

      ;; Inverse properties
      (for-each (t (prp-inv1 arena g delta))
        (set! result (delta-add arena result t)))
      (for-each (t (prp-inv2 arena g delta))
        (set! result (delta-add arena result t)))

      ;; Property chains and hasKey
      (for-each (t (prp-spo2 arena g delta))
        (set! result (delta-add arena result t)))
      (for-each (t (prp-key arena g delta))
        (set! result (delta-add arena result t)))

      (ok result)))

  ;; ============================================================
  ;; prp-dom: Domain Inference
  ;;
  ;; If (?p rdfs:domain ?c) and (?x ?p ?y)
  ;; then (?x rdf:type ?c)
  ;; ============================================================

  (fn prp-dom ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Infer type from property domain")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@post (all-triples-have-predicate $result RDF_TYPE))
    (@property soundness
      (forall (t $result)
        (exists (dt (. delta triples))
          (and
            (term-eq (triple-subject t) (triple-subject dt))
            (term-eq (triple-predicate t) (make-iri arena RDF_TYPE))
            (indexed-graph-contains g
              (make-triple arena (triple-predicate dt) (make-iri arena RDFS_DOMAIN) (triple-object t)))))))
    (@example
      ;; Graph: (hasChild domain Person), (alice hasChild bob)
      ;; Result: (alice type Person)
      :eq triple-eq
      (arena (fixture-g-domain arena) (fixture-delta-usage arena))
      -> (list (make-triple arena (make-iri arena EX_ALICE) (make-iri arena RDF_TYPE) (make-iri arena EX_PERSON))))
    (let ((domain-pred (make-iri arena RDFS_DOMAIN))
          (type-pred (make-iri arena RDF_TYPE))
          (no-term (Option Term) (none))
          (mut result (list-new arena Triple)))

      ;; For each triple in delta, check if its predicate has a domain
      (for-each (dt (. delta triples))
        (@loop-invariant
          (forall (t result)
            (exists (src-dt (. delta triples))
              (and
                (term-eq (triple-subject t) (triple-subject src-dt))
                (term-eq (triple-predicate t) (make-iri arena RDF_TYPE))
                (indexed-graph-contains g
                  (make-triple arena (triple-predicate src-dt) (make-iri arena RDFS_DOMAIN) (triple-object t)))))))
        (let ((x (triple-subject dt))
              (p (triple-predicate dt)))
          ;; Find domain declarations for p
          (indexed-graph-for-each g (some p) (some domain-pred) no-term
            (fn ((dom-triple Triple))
              (let ((c (triple-object dom-triple))
                    (inferred (make-triple arena x type-pred c)))
                (when (not (indexed-graph-contains g inferred))
                  (list-push result inferred)))))))

      result))

  ;; ============================================================
  ;; prp-rng: Range Inference
  ;;
  ;; If (?p rdfs:range ?c) and (?x ?p ?y)
  ;; then (?y rdf:type ?c)
  ;; ============================================================

  (fn prp-rng ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Infer type from property range")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@post (all-triples-have-predicate $result RDF_TYPE))
    (@property soundness
      (forall (t $result)
        (exists (dt (. delta triples))
          (and
            (term-eq (triple-subject t) (triple-object dt))
            (term-eq (triple-predicate t) (make-iri arena RDF_TYPE))
            (indexed-graph-contains g
              (make-triple arena (triple-predicate dt) (make-iri arena RDFS_RANGE) (triple-object t)))))))
    (@example
      ;; Graph: (hasChild range Person), (alice hasChild bob)
      ;; Result: (bob type Person)
      (arena (fixture-g-range arena) (fixture-delta-usage arena))
      -> (list (make-triple arena (make-iri arena EX_BOB) (make-iri arena RDF_TYPE) (make-iri arena EX_PERSON))))
    (let ((range-pred (make-iri arena RDFS_RANGE))
          (type-pred (make-iri arena RDF_TYPE))
          (no-term (Option Term) (none))
          (mut result (list-new arena Triple)))

      (for-each (dt (. delta triples))
        (@loop-invariant
          (forall (t result)
            (exists (src-dt (. delta triples))
              (and
                (term-eq (triple-subject t) (triple-object src-dt))
                (term-eq (triple-predicate t) (make-iri arena RDF_TYPE))
                (indexed-graph-contains g
                  (make-triple arena (triple-predicate src-dt) (make-iri arena RDFS_RANGE) (triple-object t)))))))
        (let ((y (triple-object dt))
              (p (triple-predicate dt)))
          ;; Only apply to non-literal objects
          (indexed-graph-for-each g (some p) (some range-pred) no-term
            (fn ((rng-triple Triple))
              (let ((c (triple-object rng-triple))
                    (inferred (make-triple arena y type-pred c)))
                (when (not (indexed-graph-contains g inferred))
                  (list-push result inferred)))))))

      result))

  ;; ============================================================
  ;; prp-fp: Functional Property
  ;;
  ;; If (?p rdf:type owl:FunctionalProperty) and
  ;;    (?x ?p ?y1) and (?x ?p ?y2)
  ;; then (?y1 owl:sameAs ?y2)
  ;; ============================================================

  (fn prp-fp ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Infer sameAs from functional property")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@post (all-triples-have-predicate $result OWL_SAME_AS))
    (@property soundness
      (forall (t $result)
        (exists (dt (. delta triples))
          (and
            (term-eq (triple-predicate t) (make-iri arena OWL_SAME_AS))
            (term-eq (triple-subject t) (triple-object dt))
            (indexed-graph-contains g
              (make-triple arena (triple-predicate dt) (make-iri arena RDF_TYPE) (make-iri arena OWL_FUNCTIONAL_PROPERTY)))
            (indexed-graph-contains g
              (make-triple arena (triple-subject dt) (triple-predicate dt) (triple-object t)))))))
    (@example
      ;; Graph: (hasMother type FunctionalProperty), (alice hasMother mary), (alice hasMother maria)
      ;; Result: (mary sameAs maria)
      (arena (fixture-g-functional arena) (fixture-delta-functional arena))
      -> (list (make-triple arena (make-iri arena EX_MARY) (make-iri arena OWL_SAME_AS) (make-iri arena EX_MARIA))))
    (let ((fp-type (make-iri arena OWL_FUNCTIONAL_PROPERTY))
          (type-pred (make-iri arena RDF_TYPE))
          (same-as (make-iri arena OWL_SAME_AS))
          (no-term (Option Term) (none))
          (mut result (list-new arena Triple)))

      ;; Find all functional properties
      (indexed-graph-for-each g no-term (some type-pred) (some fp-type)
        (fn ((fp-triple Triple))
          (let ((p (triple-subject fp-triple)))
            ;; For each usage of p in delta (indexed by predicate)
            (match (map-get (. delta by-predicate) p)
              ((some pred-triples)
                (for-each (dt pred-triples)
                  (let ((x (triple-subject dt))
                        (y1 (triple-object dt)))
                    ;; Find other values for same subject
                    (indexed-graph-for-each g (some x) (some p) no-term
                      (fn ((other-triple Triple))
                        (let ((y2 (triple-object other-triple)))
                          (when (not (term-eq y1 y2))
                            (let ((inferred (make-triple arena y1 same-as y2)))
                              (when (not (indexed-graph-contains g inferred))
                                (list-push result inferred))))))))))
              ((none) (do))))))

      result))

  ;; ============================================================
  ;; prp-ifp: Inverse Functional Property
  ;;
  ;; If (?p rdf:type owl:InverseFunctionalProperty) and
  ;;    (?x1 ?p ?y) and (?x2 ?p ?y)
  ;; then (?x1 owl:sameAs ?x2)
  ;; ============================================================

  (fn prp-ifp ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Infer sameAs from inverse functional property")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@post (all-triples-have-predicate $result OWL_SAME_AS))
    (@property soundness
      (forall (t $result)
        (exists (dt (. delta triples))
          (and
            (term-eq (triple-predicate t) (make-iri arena OWL_SAME_AS))
            (term-eq (triple-subject t) (triple-subject dt))
            (indexed-graph-contains g
              (make-triple arena (triple-predicate dt) (make-iri arena RDF_TYPE) (make-iri arena OWL_INVERSE_FUNCTIONAL_PROPERTY)))
            (indexed-graph-contains g
              (make-triple arena (triple-object t) (triple-predicate dt) (triple-object dt)))))))
    (@example
      ;; Graph: (ssn type InverseFunctionalProperty), (alice ssn "123"), (alicia ssn "123")
      ;; Result: (alice sameAs alicia)
      (arena (fixture-g-ifp arena) (fixture-delta-ifp arena))
      -> (list (make-triple arena (make-iri arena EX_ALICE) (make-iri arena OWL_SAME_AS) (make-iri arena EX_ALICIA))))
    (let ((ifp-type (make-iri arena OWL_INVERSE_FUNCTIONAL_PROPERTY))
          (type-pred (make-iri arena RDF_TYPE))
          (same-as (make-iri arena OWL_SAME_AS))
          (no-term (Option Term) (none))
          (mut result (list-new arena Triple)))

      (indexed-graph-for-each g no-term (some type-pred) (some ifp-type)
        (fn ((ifp-triple Triple))
          (let ((p (triple-subject ifp-triple)))
            (match (map-get (. delta by-predicate) p)
              ((some pred-triples)
                (for-each (dt pred-triples)
                  (let ((x1 (triple-subject dt))
                        (y (triple-object dt)))
                    ;; Find other subjects with same object
                    (indexed-graph-for-each g no-term (some p) (some y)
                      (fn ((other-triple Triple))
                        (let ((x2 (triple-subject other-triple)))
                          (when (not (term-eq x1 x2))
                            (let ((inferred (make-triple arena x1 same-as x2)))
                              (when (not (indexed-graph-contains g inferred))
                                (list-push result inferred))))))))))
              ((none) (do))))))

      result))

  ;; ============================================================
  ;; prp-symp: Symmetric Property
  ;;
  ;; If (?p rdf:type owl:SymmetricProperty) and (?x ?p ?y)
  ;; then (?y ?p ?x)
  ;; ============================================================

  (fn prp-symp ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Infer symmetric property assertion")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@property soundness
      (forall (t $result)
        (exists (dt (. delta triples))
          (and
            (term-eq (triple-subject t) (triple-object dt))
            (term-eq (triple-predicate t) (triple-predicate dt))
            (term-eq (triple-object t) (triple-subject dt))
            (indexed-graph-contains g
              (make-triple arena (triple-predicate dt) (make-iri arena RDF_TYPE) (make-iri arena OWL_SYMMETRIC_PROPERTY)))))))
    (@property completeness
      (forall (dt (. delta triples))
        (or (not (indexed-graph-contains g
              (make-triple arena (triple-predicate dt) (make-iri arena RDF_TYPE) (make-iri arena OWL_SYMMETRIC_PROPERTY))))
            (indexed-graph-contains g
              (make-triple arena (triple-object dt) (triple-predicate dt) (triple-subject dt)))
            (list-contains $result
              (make-triple arena (triple-object dt) (triple-predicate dt) (triple-subject dt))))))
    (@example
      ;; Graph: (knows type SymmetricProperty), (alice knows bob)
      ;; Result: (bob knows alice)
      (arena (fixture-g-symmetric arena) (fixture-delta-symmetric arena))
      -> (list (make-triple arena (make-iri arena EX_BOB) (make-iri arena EX_KNOWS) (make-iri arena EX_ALICE))))
    (let ((sym-type (make-iri arena OWL_SYMMETRIC_PROPERTY))
          (type-pred (make-iri arena RDF_TYPE))
          (no-term (Option Term) (none))
          (mut result (list-new arena Triple)))

      (indexed-graph-for-each g no-term (some type-pred) (some sym-type)
        (fn ((sym-triple Triple))
          (let ((p (triple-subject sym-triple)))
            (match (map-get (. delta by-predicate) p)
              ((some pred-triples)
                (for-each (dt pred-triples)
                  (let ((x (triple-subject dt))
                        (y (triple-object dt))
                        (inferred (make-triple arena y p x)))
                    (when (not (indexed-graph-contains g inferred))
                      (list-push result inferred)))))
              ((none) (do))))))

      result))

  ;; ============================================================
  ;; prp-asyp: Asymmetric Property Violation
  ;;
  ;; If (?p rdf:type owl:AsymmetricProperty) and (?x ?p ?y) and (?y ?p ?x)
  ;; then INCONSISTENT
  ;; ============================================================

  (fn prp-asyp ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Detect asymmetric property violation")
    (@spec ((Arena IndexedGraph Delta) -> (Option InconsistencyReport)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post (match $result
             ((none) true)
             ((some r) (>= (list-len (. r witnesses)) 2))))
    (@example
      ;; Graph: (hasParent type AsymmetricProperty), (alice hasParent bob), (bob hasParent alice)
      ;; Result: inconsistency
      (arena (fixture-g-asym-violation arena) (fixture-delta-asymmetric arena))
      -> (some (InconsistencyReport "prp-asyp: asymmetric property used symmetrically" _)))
    (let ((asym-type (make-iri arena OWL_ASYMMETRIC_PROPERTY))
          (type-pred (make-iri arena RDF_TYPE))
          (no-term (Option Term) (none)))

      (let ((asym-triples (indexed-graph-match arena g no-term (some type-pred) (some asym-type))))
        (for-each (asym-triple asym-triples)
          (let ((p (triple-subject asym-triple)))
            (match (map-get (. delta by-predicate) p)
              ((some pred-triples)
                (for-each (dt pred-triples)
                  (let ((x (triple-subject dt))
                        (y (triple-object dt))
                        (reverse (make-triple arena y p x)))
                    (when (indexed-graph-contains g reverse)
                      (return (some (record-new InconsistencyReport
                        (reason "prp-asyp: asymmetric property used symmetrically")
                        (witnesses (list Triple dt reverse asym-triple)))))))))
              ((none) (do))))))

      (none)))

  ;; ============================================================
  ;; prp-trp: Transitive Property
  ;;
  ;; If (?p rdf:type owl:TransitiveProperty) and (?x ?p ?y) and (?y ?p ?z)
  ;; then (?x ?p ?z)
  ;; ============================================================

  (fn prp-trp ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Infer transitive property closure")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@property soundness
      (forall (t $result)
        (exists (dt (. delta triples))
          (and
            (term-eq (triple-predicate t) (triple-predicate dt))
            (indexed-graph-contains g
              (make-triple arena (triple-predicate dt) (make-iri arena RDF_TYPE) (make-iri arena OWL_TRANSITIVE_PROPERTY)))
            (or
              ;; Forward: (x p y) in delta, (y p z) in graph → (x p z)
              (and (term-eq (triple-subject t) (triple-subject dt))
                   (indexed-graph-contains g
                     (make-triple arena (triple-object dt) (triple-predicate dt) (triple-object t))))
              ;; Backward: (x p y) in delta, (w p x) in graph → (w p y)
              (and (term-eq (triple-object t) (triple-object dt))
                   (indexed-graph-contains g
                     (make-triple arena (triple-subject t) (triple-predicate dt) (triple-subject dt)))))))))
    (@example
      ;; Graph: (ancestor type TransitiveProperty), (a ancestor b), (b ancestor c)
      ;; Result: (a ancestor c)
      (arena (fixture-g-transitive arena) (fixture-delta-transitive arena))
      -> (list (make-triple arena (make-iri arena EX_A) (make-iri arena EX_ANCESTOR) (make-iri arena EX_C))))
    (let ((trans-type (make-iri arena OWL_TRANSITIVE_PROPERTY))
          (type-pred (make-iri arena RDF_TYPE))
          (no-term (Option Term) (none))
          (mut result (list-new arena Triple)))

      (indexed-graph-for-each g no-term (some type-pred) (some trans-type)
        (fn ((trans-triple Triple))
          (let ((p (triple-subject trans-triple)))
            (match (map-get (. delta by-predicate) p)
              ((some pred-triples)
                (for-each (dt pred-triples)
                  (let ((x (triple-subject dt))
                        (y (triple-object dt)))
                    ;; Find y ?p ?z
                    (indexed-graph-for-each g (some y) (some p) no-term
                      (fn ((next-triple Triple))
                        (let ((z (triple-object next-triple))
                              (inferred (make-triple arena x p z)))
                          (when (not (indexed-graph-contains g inferred))
                            (list-push result inferred)))))
                    ;; Find ?w ?p ?x
                    (indexed-graph-for-each g no-term (some p) (some x)
                      (fn ((prev-triple Triple))
                        (let ((w (triple-subject prev-triple))
                              (inferred (make-triple arena w p y)))
                          (when (not (indexed-graph-contains g inferred))
                            (list-push result inferred))))))))
              ((none) (do))))))

      result))

  ;; ============================================================
  ;; prp-irp: Irreflexive Property Violation
  ;;
  ;; If (?p rdf:type owl:IrreflexiveProperty) and (?x ?p ?x)
  ;; then INCONSISTENT
  ;; ============================================================

  (fn prp-irp ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Detect irreflexive property violation (self-reference)")
    (@spec ((Arena IndexedGraph Delta) -> (Option InconsistencyReport)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post (match $result
             ((none) true)
             ((some r) (>= (list-len (. r witnesses)) 1))))
    (@example
      ;; Graph: (hasParent type IrreflexiveProperty), (alice hasParent alice)
      ;; Result: inconsistency
      (arena (fixture-g-irp-violation arena) (fixture-delta-irreflexive arena))
      -> (some (InconsistencyReport "prp-irp: irreflexive property used reflexively" _)))
    (let ((irp-type (make-iri arena OWL_IRREFLEXIVE_PROPERTY))
          (type-pred (make-iri arena RDF_TYPE))
          (no-term (Option Term) (none)))

      (let ((irp-triples (indexed-graph-match arena g no-term (some type-pred) (some irp-type))))
        (for-each (irp-triple irp-triples)
          (let ((p (triple-subject irp-triple)))
            (match (map-get (. delta by-predicate) p)
              ((some pred-triples)
                (for-each (dt pred-triples)
                  (let ((x (triple-subject dt))
                        (y (triple-object dt)))
                    (when (term-eq x y)
                      (return (some (record-new InconsistencyReport
                        (reason "prp-irp: irreflexive property used reflexively")
                        (witnesses (list Triple dt irp-triple)))))))))
              ((none) (do))))))

      (none)))

  ;; ============================================================
  ;; prp-adp: AllDisjointProperties Inconsistency
  ;;
  ;; If (?x rdf:type owl:AllDisjointProperties) and
  ;;    (?x owl:members ?list) and LIST(?list, ?p1, ..., ?pn) and
  ;;    (?a ?pi ?b) and (?a ?pj ?b) for i != j
  ;; then INCONSISTENT
  ;; ============================================================

  (fn prp-adp ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Detect AllDisjointProperties violations - same pair via two disjoint properties")
    (@spec ((Arena IndexedGraph Delta) -> (Option InconsistencyReport)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post (match $result
             ((none) true)
             ((some r) (> (string-len (. r reason)) 0))))
    (@post (match $result
             ((none) true)
             ((some r) (>= (list-len (. r witnesses)) 2))))
    (let ((adp-class (make-iri arena OWL_ALL_DISJOINT_PROPERTIES))
          (type-pred (make-iri arena RDF_TYPE))
          (members-pred (make-iri arena OWL_MEMBERS))
          (no-term (Option Term) (none)))

      ;; Find all AllDisjointProperties declarations
      (let ((adp-triples (indexed-graph-match arena g no-term (some type-pred) (some adp-class))))
        (for-each (adp-triple adp-triples)
          (let ((adp-node (triple-subject adp-triple)))
            ;; Get the members list
            (let ((m-triples (indexed-graph-match arena g (some adp-node) (some members-pred) no-term)))
              (for-each (m-triple m-triples)
                (let ((list-head (triple-object m-triple))
                      (props (rdf-list-elements-indexed arena g list-head)))
                  ;; For each pair of properties in the list
                  (for-each (pi props)
                    (for-each (pj props)
                      (when (not (term-eq pi pj))
                        ;; Check delta for pi assertions, look in graph for matching pj
                        (match (map-get (. delta by-predicate) pi)
                          ((some pred-triples)
                            (for-each (dt pred-triples)
                              (let ((a (triple-subject dt))
                                    (b (triple-object dt))
                                    (conflict (make-triple arena a pj b)))
                                (when (indexed-graph-contains g conflict)
                                  (return (some (record-new InconsistencyReport
                                    (reason "prp-adp: same pair asserted via two properties in AllDisjointProperties")
                                    (witnesses (list Triple dt conflict adp-triple)))))))))
                          ((none) (do))))))))))))

      (none)))

  ;; ============================================================
  ;; prp-npa1: Negative Property Assertion (Named Individual)
  ;;
  ;; If (?x owl:sourceIndividual ?s) and (?x owl:assertionProperty ?p) and
  ;;    (?x owl:targetIndividual ?o) and (?s ?p ?o)
  ;; then INCONSISTENT
  ;; ============================================================

  (fn prp-npa1 ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Detect negative property assertion violation for named individuals")
    (@spec ((Arena IndexedGraph Delta) -> (Option InconsistencyReport)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post (match $result
             ((none) true)
             ((some r) (> (string-len (. r reason)) 0))))
    (@post (match $result
             ((none) true)
             ((some r) (>= (list-len (. r witnesses)) 1))))
    (let ((source-pred (make-iri arena OWL_SOURCE_INDIVIDUAL))
          (assert-pred (make-iri arena OWL_ASSERTION_PROPERTY))
          (target-pred (make-iri arena OWL_TARGET_INDIVIDUAL))
          (no-term (Option Term) (none)))

      ;; Find all negative property assertions: (?x sourceIndividual ?s)
      (let ((npa-triples (indexed-graph-match arena g no-term (some source-pred) no-term)))
        (for-each (npa-triple npa-triples)
          (let ((x (triple-subject npa-triple))
                (s (triple-object npa-triple)))
            ;; Get the assertion property
            (let ((ap-triples (indexed-graph-match arena g (some x) (some assert-pred) no-term)))
              (for-each (ap-triple ap-triples)
                (let ((p (triple-object ap-triple)))
                  ;; Get the target individual
                  (let ((ti-triples (indexed-graph-match arena g (some x) (some target-pred) no-term)))
                    (for-each (ti-triple ti-triples)
                      (let ((o (triple-object ti-triple))
                            (asserted (make-triple arena s p o)))
                        ;; Check if the asserted triple exists in graph
                        (when (indexed-graph-contains g asserted)
                          (return (some (record-new InconsistencyReport
                            (reason "prp-npa1: negative property assertion violated (named individual)")
                            (witnesses (list Triple asserted npa-triple ap-triple ti-triple)))))))))))))))

      (none)))

  ;; ============================================================
  ;; prp-npa2: Negative Property Assertion (Literal)
  ;;
  ;; If (?x owl:sourceIndividual ?s) and (?x owl:assertionProperty ?p) and
  ;;    (?x owl:targetValue ?v) and (?s ?p ?v)
  ;; then INCONSISTENT
  ;; ============================================================

  (fn prp-npa2 ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Detect negative property assertion violation for literal values")
    (@spec ((Arena IndexedGraph Delta) -> (Option InconsistencyReport)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post (match $result
             ((none) true)
             ((some r) (> (string-len (. r reason)) 0))))
    (@post (match $result
             ((none) true)
             ((some r) (>= (list-len (. r witnesses)) 1))))
    (let ((source-pred (make-iri arena OWL_SOURCE_INDIVIDUAL))
          (assert-pred (make-iri arena OWL_ASSERTION_PROPERTY))
          (target-pred (make-iri arena OWL_TARGET_VALUE))
          (no-term (Option Term) (none)))

      ;; Find all negative property assertions: (?x sourceIndividual ?s)
      (let ((npa-triples (indexed-graph-match arena g no-term (some source-pred) no-term)))
        (for-each (npa-triple npa-triples)
          (let ((x (triple-subject npa-triple))
                (s (triple-object npa-triple)))
            ;; Get the assertion property
            (let ((ap-triples (indexed-graph-match arena g (some x) (some assert-pred) no-term)))
              (for-each (ap-triple ap-triples)
                (let ((p (triple-object ap-triple)))
                  ;; Get the target value
                  (let ((tv-triples (indexed-graph-match arena g (some x) (some target-pred) no-term)))
                    (for-each (tv-triple tv-triples)
                      (let ((v (triple-object tv-triple))
                            (asserted (make-triple arena s p v)))
                        ;; Check if the asserted triple exists in graph
                        (when (indexed-graph-contains g asserted)
                          (return (some (record-new InconsistencyReport
                            (reason "prp-npa2: negative property assertion violated (literal)")
                            (witnesses (list Triple asserted npa-triple ap-triple tv-triple)))))))))))))))

      (none)))

  ;; ============================================================
  ;; prp-spo2: Property Chain Axiom
  ;;
  ;; If (?p owl:propertyChainAxiom ?list) and LIST(?list, ?p1, ..., ?pn) and
  ;;    (?x0 ?p1 ?x1) and (?x1 ?p2 ?x2) and ... and (?xn-1 ?pn ?xn)
  ;; then (?x0 ?p ?xn)
  ;; ============================================================

  (fn prp-spo2 ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Infer property assertions from property chain axioms")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@property soundness
      (forall (t $result)
        (exists (dt (. delta triples))
          ;; Every inferred triple is new (not already in the graph)
          ;; and was derived from a delta-driven chain walk.
          ;; Full chain path validation (variable-length) beyond annotation.
          (not (indexed-graph-contains g t)))))
    (let ((chain-pred (make-iri arena OWL_PROPERTY_CHAIN_AXIOM))
          (no-term (Option Term) (none))
          (mut result (list-new arena Triple)))

      ;; Find all property chain axioms: (?p propertyChainAxiom ?list)
      ;; Use indexed-graph-match + for-each because list-push in
      ;; indexed-graph-for-each callbacks doesn't capture arena.
      (let ((chain-triples (indexed-graph-match arena g no-term (some chain-pred) no-term)))
        (for-each (chain-triple chain-triples)
          (let ((target-prop (triple-subject chain-triple))
                (list-head (triple-object chain-triple))
                (chain-props (rdf-list-elements-indexed arena g list-head))
                (chain-len (list-len chain-props)))
            ;; Only process chains with at least 2 properties
            (when (>= chain-len 2)
              ;; For each triple in delta, check if it matches any property in the chain
              (for-each (dt (. delta triples))
                (let ((dt-pred (triple-predicate dt)))
                  ;; Try starting from each position in the chain
                  (let ((mut ci 0))
                    (while (< ci chain-len)
                      (match (list-get chain-props ci)
                        ((some chain-p)
                          (when (term-eq dt-pred chain-p)
                            ;; Delta triple matches chain[ci]
                            ;; Walk backward from ci to find the chain start
                            (let ((mut starts (list-new arena Term)))
                              (list-push starts (triple-subject dt))
                              (let ((mut bi (- ci 1)))
                                (while (>= bi 0)
                                  (match (list-get chain-props bi)
                                    ((some prev-p)
                                      (let ((mut new-starts (list-new arena Term)))
                                        (for-each (s starts)
                                          ;; Find (? prev-p s) — things linked to s via prev-p
                                          (let ((back-triples (indexed-graph-match arena g no-term (some prev-p) (some s))))
                                            (for-each (bt back-triples)
                                              (list-push new-starts (triple-subject bt)))))
                                        (set! starts new-starts)))
                                    ((none) (do)))
                                  (set! bi (- bi 1))))
                              ;; Walk forward from ci to find the chain end
                              (let ((mut ends (list-new arena Term)))
                                (list-push ends (triple-object dt))
                                (let ((mut fi (+ ci 1)))
                                  (while (< fi chain-len)
                                    (match (list-get chain-props fi)
                                      ((some next-p)
                                        (let ((mut new-ends (list-new arena Term)))
                                          (for-each (e ends)
                                            ;; Find (e next-p ?)
                                            (let ((fwd-triples (indexed-graph-match arena g (some e) (some next-p) no-term)))
                                              (for-each (ft fwd-triples)
                                                (list-push new-ends (triple-object ft)))))
                                          (set! ends new-ends)))
                                      ((none) (do)))
                                    (set! fi (+ fi 1))))
                                ;; Create inferred triples for all start-end combinations
                                (for-each (s starts)
                                  (for-each (e ends)
                                    (let ((inferred (make-triple arena s target-prop e)))
                                      (when (not (indexed-graph-contains g inferred))
                                        (list-push result inferred)))))))))
                        ((none) (do)))
                      (set! ci (+ ci 1))))))))))

      result))

  ;; ============================================================
  ;; prp-key: hasKey
  ;;
  ;; If (?c owl:hasKey ?list) and LIST(?list, ?k1, ..., ?kn) and
  ;;    (?x rdf:type ?c) and (?y rdf:type ?c) and
  ;;    (?x ?k1 ?v1) and (?y ?k1 ?v1) and ... and (?x ?kn ?vn) and (?y ?kn ?vn)
  ;; then (?x owl:sameAs ?y)
  ;; ============================================================

  (fn prp-key ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Infer sameAs from hasKey — individuals with same key values are equal")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@post (all-triples-have-predicate $result OWL_SAME_AS))
    (@property soundness
      (forall (t $result)
        (exists (dt (. delta triples))
          (and
            ;; (?x owl:sameAs ?y) — the conclusion
            (term-eq (triple-subject t) (triple-subject dt))
            (term-eq (triple-predicate t) (make-iri arena OWL_SAME_AS))
            ;; (?x rdf:type ?c) — dt is a type assertion from delta
            (term-eq (triple-predicate dt) (make-iri arena RDF_TYPE))
            ;; (?y rdf:type ?c) — y has same type in graph
            (indexed-graph-contains g
              (make-triple arena (triple-object t) (make-iri arena RDF_TYPE) (triple-object dt)))
            ;; Result is new
            (not (indexed-graph-contains g t))))))
    (let ((key-pred (make-iri arena OWL_HAS_KEY))
          (type-pred (make-iri arena RDF_TYPE))
          (same-as (make-iri arena OWL_SAME_AS))
          (no-term (Option Term) (none))
          (mut result (list-new arena Triple)))

      ;; Find all hasKey declarations: (?c owl:hasKey ?list)
      ;; Use indexed-graph-match + for-each because match/list-push
      ;; inside indexed-graph-for-each callbacks don't transpile correctly.
      (let ((key-triples (indexed-graph-match arena g no-term (some key-pred) no-term)))
        (for-each (key-triple key-triples)
          (let ((key-class (triple-subject key-triple))
                (list-head (triple-object key-triple))
                (key-props (rdf-list-elements-indexed arena g list-head))
                (num-keys (list-len key-props)))
            ;; Only process if there are key properties
            (when (> num-keys 0)
              ;; For each new type assertion in delta matching the key class
              (match (map-get (. delta by-predicate) type-pred)
                ((some type-triples)
                  (for-each (dt type-triples)
                    (when (term-eq (triple-object dt) key-class)
                      (let ((x (triple-subject dt)))
                        ;; Check if x has values for all key properties
                        (let ((mut x-has-all-keys true))
                          (for-each (kp key-props)
                            (let ((x-vals (indexed-graph-match arena g (some x) (some kp) no-term)))
                              (when (== (list-len x-vals) 0)
                                (set! x-has-all-keys false))))
                          ;; Only proceed if x has values for all key properties
                          (when x-has-all-keys
                            ;; Find all other instances of key-class in the graph
                            (let ((y-triples (indexed-graph-match arena g no-term (some type-pred) (some key-class))))
                              (for-each (yt y-triples)
                                (let ((y (triple-subject yt)))
                                  (when (not (term-eq x y))
                                    ;; Check if y shares a value with x for every key property
                                    (let ((mut all-match true))
                                      (for-each (kp key-props)
                                        (when all-match
                                          (let ((x-vals (indexed-graph-match arena g (some x) (some kp) no-term))
                                                (mut found-match false))
                                            (for-each (xvt x-vals)
                                              (let ((y-has (make-triple arena y kp (triple-object xvt))))
                                                (when (indexed-graph-contains g y-has)
                                                  (set! found-match true))))
                                            (when (not found-match)
                                              (set! all-match false)))))
                                      (when all-match
                                        (let ((inferred (make-triple arena x same-as y)))
                                          (when (not (indexed-graph-contains g inferred))
                                            (list-push result inferred)))))))))))))))
                ((none) (do)))))))

      result))

  ;; ============================================================
  ;; prp-spo1: Subproperty Propagation
  ;;
  ;; If (?p1 rdfs:subPropertyOf ?p2) and (?x ?p1 ?y)
  ;; then (?x ?p2 ?y)
  ;; ============================================================

  (fn prp-spo1 ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Propagate property assertion through subproperty hierarchy")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@property soundness
      (forall (t $result)
        (exists (dt (. delta triples))
          (and
            (term-eq (triple-subject t) (triple-subject dt))
            (term-eq (triple-object t) (triple-object dt))
            (indexed-graph-contains g
              (make-triple arena (triple-predicate dt) (make-iri arena RDFS_SUBPROPERTY_OF) (triple-predicate t)))))))
    (@example
      ;; Graph: (hasFather subPropertyOf hasParent), (alice hasFather bob)
      ;; Result: (alice hasParent bob)
      (arena (fixture-g-subprop arena) (fixture-delta-subprop arena))
      -> (list (make-triple arena (make-iri arena EX_ALICE) (make-iri arena EX_HAS_PARENT) (make-iri arena EX_BOB))))
    (let ((subprop-pred (make-iri arena RDFS_SUBPROPERTY_OF))
          (no-term (Option Term) (none))
          (mut result (list-new arena Triple)))

      (for-each (dt (. delta triples))
        (let ((x (triple-subject dt))
              (p1 (triple-predicate dt))
              (y (triple-object dt)))
          ;; Find superproperties of p1
          (indexed-graph-for-each g (some p1) (some subprop-pred) no-term
            (fn ((super-triple Triple))
              (let ((p2 (triple-object super-triple))
                    (inferred (make-triple arena x p2 y)))
                (when (not (indexed-graph-contains g inferred))
                  (list-push result inferred)))))))

      result))

  ;; ============================================================
  ;; prp-inv1: Inverse Property (Forward)
  ;;
  ;; If (?p1 owl:inverseOf ?p2) and (?x ?p1 ?y)
  ;; then (?y ?p2 ?x)
  ;; ============================================================

  (fn prp-inv1 ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Infer inverse property assertion (forward direction)")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@property soundness
      (forall (t $result)
        (exists (dt (. delta triples))
          (and
            (term-eq (triple-subject t) (triple-object dt))
            (term-eq (triple-object t) (triple-subject dt))
            (indexed-graph-contains g
              (make-triple arena (triple-predicate dt) (make-iri arena OWL_INVERSE_OF) (triple-predicate t)))))))
    (@example
      ;; Graph: (hasParent inverseOf hasChild), (alice hasParent bob)
      ;; Result: (bob hasChild alice)
      (arena (fixture-g-inverse arena) (fixture-delta-inverse1 arena))
      -> (list (make-triple arena (make-iri arena EX_BOB) (make-iri arena EX_HAS_CHILD) (make-iri arena EX_ALICE))))
    (let ((inverse-pred (make-iri arena OWL_INVERSE_OF))
          (no-term (Option Term) (none))
          (mut result (list-new arena Triple)))

      ;; Find p1 inverseOf p2 declarations
      (indexed-graph-for-each g no-term (some inverse-pred) no-term
        (fn ((inv-triple Triple))
          (let ((p1 (triple-subject inv-triple))
                (p2 (triple-object inv-triple)))
            ;; For each usage of p1 in delta (indexed by predicate)
            (match (map-get (. delta by-predicate) p1)
              ((some pred-triples)
                (for-each (dt pred-triples)
                  (let ((x (triple-subject dt))
                        (y (triple-object dt))
                        (inferred (make-triple arena y p2 x)))
                    (when (not (indexed-graph-contains g inferred))
                      (list-push result inferred)))))
              ((none) (do))))))

      result))

  ;; ============================================================
  ;; prp-inv2: Inverse Property (Backward)
  ;;
  ;; If (?p1 owl:inverseOf ?p2) and (?x ?p2 ?y)
  ;; then (?y ?p1 ?x)
  ;; ============================================================

  (fn prp-inv2 ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Infer inverse property assertion (backward direction)")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@property soundness
      (forall (t $result)
        (exists (dt (. delta triples))
          (and
            (term-eq (triple-subject t) (triple-object dt))
            (term-eq (triple-object t) (triple-subject dt))
            (indexed-graph-contains g
              (make-triple arena (triple-predicate t) (make-iri arena OWL_INVERSE_OF) (triple-predicate dt)))))))
    (@example
      ;; Graph: (hasParent inverseOf hasChild), (bob hasChild alice)
      ;; Result: (alice hasParent bob)
      (arena (fixture-g-inverse arena) (fixture-delta-inverse2 arena))
      -> (list (make-triple arena (make-iri arena EX_ALICE) (make-iri arena EX_HAS_PARENT) (make-iri arena EX_BOB))))
    (let ((inverse-pred (make-iri arena OWL_INVERSE_OF))
          (no-term (Option Term) (none))
          (mut result (list-new arena Triple)))

      (indexed-graph-for-each g no-term (some inverse-pred) no-term
        (fn ((inv-triple Triple))
          (let ((p1 (triple-subject inv-triple))
                (p2 (triple-object inv-triple)))
            ;; For each usage of p2 in delta (indexed by predicate)
            (match (map-get (. delta by-predicate) p2)
              ((some pred-triples)
                (for-each (dt pred-triples)
                  (let ((x (triple-subject dt))
                        (y (triple-object dt))
                        (inferred (make-triple arena y p1 x)))
                    (when (not (indexed-graph-contains g inferred))
                      (list-push result inferred)))))
              ((none) (do))))))

      result))

  ;; ============================================================
  ;; prp-eqp1: Equivalent Property (Forward)
  ;;
  ;; If (?p1 owl:equivalentProperty ?p2) and (?x ?p1 ?y)
  ;; then (?x ?p2 ?y)
  ;; ============================================================

  (fn prp-eqp1 ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Propagate property assertion through equivalentProperty (forward)")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@property soundness
      (forall (t $result)
        (exists (dt (. delta triples))
          (and
            (term-eq (triple-subject t) (triple-subject dt))
            (term-eq (triple-object t) (triple-object dt))
            (indexed-graph-contains g
              (make-triple arena (triple-predicate dt) (make-iri arena OWL_EQUIVALENT_PROPERTY) (triple-predicate t)))))))
    (let ((equiv-pred (make-iri arena OWL_EQUIVALENT_PROPERTY))
          (no-term (Option Term) (none))
          (mut result (list-new arena Triple)))

      (indexed-graph-for-each g no-term (some equiv-pred) no-term
        (fn ((equiv-triple Triple))
          (let ((p1 (triple-subject equiv-triple))
                (p2 (triple-object equiv-triple)))
            (match (map-get (. delta by-predicate) p1)
              ((some pred-triples)
                (for-each (dt pred-triples)
                  (let ((x (triple-subject dt))
                        (y (triple-object dt))
                        (inferred (make-triple arena x p2 y)))
                    (when (not (indexed-graph-contains g inferred))
                      (list-push result inferred)))))
              ((none) (do))))))

      result))

  ;; ============================================================
  ;; prp-eqp2: Equivalent Property (Backward)
  ;;
  ;; If (?p1 owl:equivalentProperty ?p2) and (?x ?p2 ?y)
  ;; then (?x ?p1 ?y)
  ;; ============================================================

  (fn prp-eqp2 ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Propagate property assertion through equivalentProperty (backward)")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@property soundness
      (forall (t $result)
        (exists (dt (. delta triples))
          (and
            (term-eq (triple-subject t) (triple-subject dt))
            (term-eq (triple-object t) (triple-object dt))
            (indexed-graph-contains g
              (make-triple arena (triple-predicate t) (make-iri arena OWL_EQUIVALENT_PROPERTY) (triple-predicate dt)))))))
    (let ((equiv-pred (make-iri arena OWL_EQUIVALENT_PROPERTY))
          (no-term (Option Term) (none))
          (mut result (list-new arena Triple)))

      (indexed-graph-for-each g no-term (some equiv-pred) no-term
        (fn ((equiv-triple Triple))
          (let ((p1 (triple-subject equiv-triple))
                (p2 (triple-object equiv-triple)))
            (match (map-get (. delta by-predicate) p2)
              ((some pred-triples)
                (for-each (dt pred-triples)
                  (let ((x (triple-subject dt))
                        (y (triple-object dt))
                        (inferred (make-triple arena x p1 y)))
                    (when (not (indexed-graph-contains g inferred))
                      (list-push result inferred)))))
              ((none) (do))))))

      result))

  ;; ============================================================
  ;; prp-pdw: Property Disjointness Violation
  ;;
  ;; If (?p1 owl:propertyDisjointWith ?p2) and (?x ?p1 ?y) and (?x ?p2 ?y)
  ;; then INCONSISTENT
  ;; ============================================================

  (fn prp-pdw ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Detect property disjointness violation")
    (@spec ((Arena IndexedGraph Delta) -> (Option InconsistencyReport)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post (match $result
             ((none) true)
             ((some r) (>= (list-len (. r witnesses)) 3))))
    (@example
      ;; Graph: (likes propertyDisjointWith hates), (alice likes bob), (alice hates bob)
      ;; Result: inconsistency
      (arena (fixture-g-pdw-violation arena) (fixture-delta-pdw arena))
      -> (some (InconsistencyReport "prp-pdw: disjoint properties both asserted" _)))
    (let ((pdw-pred (make-iri arena OWL_PROPERTY_DISJOINT_WITH))
          (no-term (Option Term) (none)))

      (let ((pdw-triples (indexed-graph-match arena g no-term (some pdw-pred) no-term)))
        (for-each (pdw-triple pdw-triples)
          (let ((p1 (triple-subject pdw-triple))
                (p2 (triple-object pdw-triple)))
            ;; Check if delta has p1 assertions
            (match (map-get (. delta by-predicate) p1)
              ((some pred-triples)
                (for-each (dt pred-triples)
                  (let ((x (triple-subject dt))
                        (y (triple-object dt))
                        (conflict (make-triple arena x p2 y)))
                    (when (indexed-graph-contains g conflict)
                      (return (some (record-new InconsistencyReport
                        (reason "prp-pdw: disjoint properties both asserted")
                        (witnesses (list Triple dt conflict pdw-triple)))))))))
              ((none) (do)))
            ;; Also check symmetric case: delta has p2 assertions
            (match (map-get (. delta by-predicate) p2)
              ((some pred-triples)
                (for-each (dt pred-triples)
                  (let ((x (triple-subject dt))
                        (y (triple-object dt))
                        (conflict (make-triple arena x p1 y)))
                    (when (indexed-graph-contains g conflict)
                      (return (some (record-new InconsistencyReport
                        (reason "prp-pdw: disjoint properties both asserted")
                        (witnesses (list Triple dt conflict pdw-triple)))))))))
              ((none) (do))))))

      (none)))

  ;; ============================================================
  ;; prp-ap: Annotation Property Declaration
  ;;
  ;; Assert standard annotation properties as owl:AnnotationProperty.
  ;; This is a one-time materialization rule (like dt-type1).
  ;;
  ;; Behind --complete flag (noise triples with no inference value).
  ;; ============================================================

  (fn prp-ap ((arena Arena) (g IndexedGraph))
    (@intent "Assert standard annotation properties as owl:AnnotationProperty (OWL 2 RL prp-ap)")
    (@spec ((Arena IndexedGraph) -> (List Triple)))
    (@alloc arena)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@post (all-triples-have-predicate $result RDF_TYPE))
    (@property soundness
      (forall (t $result)
        (and
          (term-eq (triple-predicate t) (make-iri arena RDF_TYPE))
          (term-eq (triple-object t) (make-iri arena OWL_ANNOTATION_PROPERTY))
          (not (indexed-graph-contains g t)))))
    (let ((type-pred (make-iri arena RDF_TYPE))
          (annot-class (make-iri arena OWL_ANNOTATION_PROPERTY))
          (mut result (list-new arena Triple))
          (mut props (list-new arena String)))
      (list-push props RDFS_LABEL)
      (list-push props RDFS_COMMENT)
      (list-push props RDFS_SEE_ALSO)
      (list-push props RDFS_IS_DEFINED_BY)
      (list-push props OWL_DEPRECATED)
      (list-push props OWL_VERSION_INFO)
      (list-push props OWL_PRIOR_VERSION)
      (list-push props OWL_BACKWARD_COMPATIBLE_WITH)
      (list-push props OWL_INCOMPATIBLE_WITH)
      (for-each (p-iri props)
        (let ((p-term (make-iri arena p-iri))
              (inferred (make-triple arena p-term type-pred annot-class)))
          (when (not (indexed-graph-contains g inferred))
            (list-push result inferred))))
      result)))  ;; close fn, module
