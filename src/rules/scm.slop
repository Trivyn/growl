;; ============================================================
;; OWL 2 RL Table 9: Schema Vocabulary Rules (scm-*)
;;
;; These rules derive implicit schema-level consequences like
;; transitivity of subclass/subproperty and constraint propagation.
;;
;; Reference: https://www.w3.org/TR/owl2-profiles/#OWL_2_RL
;; ============================================================

(module scm
  (@doc "OWL 2 RL schema vocabulary rules with formally verified contracts")

  (import rdf (Term Triple term-eq triple-eq make-iri make-triple
               triple-subject triple-predicate triple-object))
  (import index (IndexedGraph indexed-graph-match indexed-graph-for-each indexed-graph-contains indexed-graph-size
                 indexed-graph-create indexed-graph-add))
  (import vocab (RDF_TYPE RDF_PROPERTY RDFS_SUBCLASS_OF RDFS_SUBPROPERTY_OF RDFS_DOMAIN RDFS_RANGE
                 OWL_CLASS OWL_THING OWL_NOTHING OWL_EQUIVALENT_CLASS OWL_EQUIVALENT_PROPERTY
                 OWL_OBJECT_PROPERTY OWL_DATATYPE_PROPERTY
                 OWL_HAS_VALUE OWL_SOME_VALUES_FROM OWL_ALL_VALUES_FROM
                 OWL_ON_PROPERTY OWL_INTERSECTION_OF OWL_UNION_OF))
  (import list (rdf-list-elements-indexed))
  (import types (Delta InconsistencyReport make-delta delta-add all-triples-have-predicate))

  (export
    apply-scm-rules
    scm-cls
    scm-sco
    scm-eqc1
    scm-eqc2
    scm-eqc-mutual
    scm-int
    scm-uni
    scm-op
    scm-dp
    scm-spo
    scm-eqp1
    scm-eqp2
    scm-eqp-mutual
    scm-dom1
    scm-dom2
    scm-rng1
    scm-rng2
    scm-svf1
    scm-svf2
    scm-avf1
    scm-avf2
    scm-hv)

  ;; ============================================================
  ;; Test Fixture URIs (for @example annotations)
  ;; ============================================================

  (const EX_PERSON String "http://example.org/Person")
  (const EX_HUMAN String "http://example.org/Human")
  (const EX_A String "http://example.org/A")
  (const EX_B String "http://example.org/B")
  (const EX_C String "http://example.org/C")
  (const EX_HAS_PARENT String "http://example.org/hasParent")
  (const EX_HAS_FATHER String "http://example.org/hasFather")
  (const EX_HAS_ANCESTOR String "http://example.org/hasAncestor")

  ;; ============================================================
  ;; Test Fixture Builders
  ;; ============================================================

  ;; Graph with (Person type owl:Class)
  (fn fixture-g-with-class ((arena Arena))
    (@intent "Create test graph: Person is an owl:Class")
    (@spec ((Arena) -> IndexedGraph))
    (let ((mut g (indexed-graph-create arena))
          (type-pred (make-iri arena RDF_TYPE))
          (class-type (make-iri arena OWL_CLASS))
          (person (make-iri arena EX_PERSON)))
      (set! g (indexed-graph-add arena g (make-triple arena person type-pred class-type)))
      g))

  ;; Graph with subclass chain: A subClassOf B, B subClassOf C
  (fn fixture-g-chain ((arena Arena))
    (@intent "Create test graph: A subClassOf B subClassOf C")
    (@spec ((Arena) -> IndexedGraph))
    (let ((mut g (indexed-graph-create arena))
          (subclass-pred (make-iri arena RDFS_SUBCLASS_OF))
          (a (make-iri arena EX_A))
          (b (make-iri arena EX_B))
          (c (make-iri arena EX_C)))
      (set! g (indexed-graph-add arena g (make-triple arena a subclass-pred b)))
      (set! g (indexed-graph-add arena g (make-triple arena b subclass-pred c)))
      g))

  ;; Graph with (Human equivalentClass Person)
  (fn fixture-g-equiv ((arena Arena))
    (@intent "Create test graph: Human equivalentClass Person")
    (@spec ((Arena) -> IndexedGraph))
    (let ((mut g (indexed-graph-create arena))
          (equiv-pred (make-iri arena OWL_EQUIVALENT_CLASS))
          (human (make-iri arena EX_HUMAN))
          (person (make-iri arena EX_PERSON)))
      (set! g (indexed-graph-add arena g (make-triple arena human equiv-pred person)))
      g))

  ;; Graph with subproperty chain: hasFather subPropertyOf hasParent subPropertyOf hasAncestor
  (fn fixture-g-prop-chain ((arena Arena))
    (@intent "Create test graph: property subproperty chain")
    (@spec ((Arena) -> IndexedGraph))
    (let ((mut g (indexed-graph-create arena))
          (subprop-pred (make-iri arena RDFS_SUBPROPERTY_OF))
          (has-father (make-iri arena EX_HAS_FATHER))
          (has-parent (make-iri arena EX_HAS_PARENT))
          (has-ancestor (make-iri arena EX_HAS_ANCESTOR)))
      (set! g (indexed-graph-add arena g (make-triple arena has-father subprop-pred has-parent)))
      (set! g (indexed-graph-add arena g (make-triple arena has-parent subprop-pred has-ancestor)))
      g))

  ;; Graph with domain declaration: hasParent domain Person, hasFather subPropertyOf hasParent
  (fn fixture-g-domain ((arena Arena))
    (@intent "Create test graph: domain propagation scenario")
    (@spec ((Arena) -> IndexedGraph))
    (let ((mut g (indexed-graph-create arena))
          (domain-pred (make-iri arena RDFS_DOMAIN))
          (subprop-pred (make-iri arena RDFS_SUBPROPERTY_OF))
          (has-parent (make-iri arena EX_HAS_PARENT))
          (has-father (make-iri arena EX_HAS_FATHER))
          (person (make-iri arena EX_PERSON)))
      (set! g (indexed-graph-add arena g (make-triple arena has-parent domain-pred person)))
      (set! g (indexed-graph-add arena g (make-triple arena has-father subprop-pred has-parent)))
      g))

  ;; Delta with (B subClassOf C) - new link in chain
  (fn fixture-delta-new-link ((arena Arena))
    (@intent "Create delta: B subClassOf C")
    (@spec ((Arena) -> Delta))
    (let ((mut d (make-delta arena 0))
          (subclass-pred (make-iri arena RDFS_SUBCLASS_OF))
          (b (make-iri arena EX_B))
          (c (make-iri arena EX_C)))
      (set! d (delta-add arena d (make-triple arena b subclass-pred c)))
      d))

  ;; Empty delta
  (fn fixture-delta-empty ((arena Arena))
    (@intent "Create empty delta")
    (@spec ((Arena) -> Delta))
    (make-delta arena 0))

  ;; Delta with (Person type owl:Class)
  (fn fixture-delta-with-class ((arena Arena))
    (@intent "Create delta: Person is an owl:Class")
    (@spec ((Arena) -> Delta))
    (let ((mut d (make-delta arena 0))
          (type-pred (make-iri arena RDF_TYPE))
          (class-type (make-iri arena OWL_CLASS))
          (person (make-iri arena EX_PERSON)))
      (set! d (delta-add arena d (make-triple arena person type-pred class-type)))
      d))

  ;; Delta with (Human equivalentClass Person)
  (fn fixture-delta-equiv ((arena Arena))
    (@intent "Create delta: Human equivalentClass Person")
    (@spec ((Arena) -> Delta))
    (let ((mut d (make-delta arena 0))
          (equiv-pred (make-iri arena OWL_EQUIVALENT_CLASS))
          (human (make-iri arena EX_HUMAN))
          (person (make-iri arena EX_PERSON)))
      (set! d (delta-add arena d (make-triple arena human equiv-pred person)))
      d))

  ;; Delta with (hasFather subPropertyOf hasParent)
  (fn fixture-delta-subprop ((arena Arena))
    (@intent "Create delta: hasFather subPropertyOf hasParent")
    (@spec ((Arena) -> Delta))
    (let ((mut d (make-delta arena 0))
          (subprop-pred (make-iri arena RDFS_SUBPROPERTY_OF))
          (has-father (make-iri arena EX_HAS_FATHER))
          (has-parent (make-iri arena EX_HAS_PARENT)))
      (set! d (delta-add arena d (make-triple arena has-father subprop-pred has-parent)))
      d))

  ;; ============================================================
  ;; Rule Dispatcher
  ;; ============================================================

  (fn apply-scm-rules ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Apply all schema vocabulary rules (Table 9)")
    (@spec ((Arena IndexedGraph Delta) -> (Result Delta InconsistencyReport)))
    (@alloc arena)
    (@pre {(indexed-graph-size g) >= 0})
    (@post (match $result
             ((ok d) {(. d iteration) == (+ (. delta iteration) 1)})
             ((error _) true)))
    (let ((next-iter (+ (. delta iteration) 1))
          (mut result (make-delta arena next-iter)))

      ;; Class schema rules
      (for-each (t (scm-cls arena g delta))
        (set! result (delta-add arena result t)))
      (for-each (t (scm-sco arena g delta))
        (set! result (delta-add arena result t)))
      (for-each (t (scm-eqc1 arena g delta))
        (set! result (delta-add arena result t)))
      (for-each (t (scm-eqc2 arena g delta))
        (set! result (delta-add arena result t)))
      (for-each (t (scm-eqc-mutual arena g delta))
        (set! result (delta-add arena result t)))
      (for-each (t (scm-int arena g delta))
        (set! result (delta-add arena result t)))
      (for-each (t (scm-uni arena g delta))
        (set! result (delta-add arena result t)))

      ;; Property schema rules
      (for-each (t (scm-op arena g delta))
        (set! result (delta-add arena result t)))
      (for-each (t (scm-dp arena g delta))
        (set! result (delta-add arena result t)))
      (for-each (t (scm-spo arena g delta))
        (set! result (delta-add arena result t)))
      (for-each (t (scm-eqp1 arena g delta))
        (set! result (delta-add arena result t)))
      (for-each (t (scm-eqp2 arena g delta))
        (set! result (delta-add arena result t)))
      (for-each (t (scm-eqp-mutual arena g delta))
        (set! result (delta-add arena result t)))

      ;; Domain/range rules
      (for-each (t (scm-dom1 arena g delta))
        (set! result (delta-add arena result t)))
      (for-each (t (scm-dom2 arena g delta))
        (set! result (delta-add arena result t)))
      (for-each (t (scm-rng1 arena g delta))
        (set! result (delta-add arena result t)))
      (for-each (t (scm-rng2 arena g delta))
        (set! result (delta-add arena result t)))

      ;; Restriction schema rules
      (for-each (t (scm-svf1 arena g delta))
        (set! result (delta-add arena result t)))
      (for-each (t (scm-svf2 arena g delta))
        (set! result (delta-add arena result t)))
      (for-each (t (scm-avf1 arena g delta))
        (set! result (delta-add arena result t)))
      (for-each (t (scm-avf2 arena g delta))
        (set! result (delta-add arena result t)))
      (for-each (t (scm-hv arena g delta))
        (set! result (delta-add arena result t)))

      (ok result)))

  ;; ============================================================
  ;; scm-cls: Every class is subclass of itself and owl:Thing
  ;;
  ;; If (?c rdf:type owl:Class)
  ;; then (?c rdfs:subClassOf ?c) and (?c rdfs:subClassOf owl:Thing)
  ;; ============================================================

  (fn scm-cls ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Infer reflexive subClassOf, subClassOf owl:Thing, Nothing subClassOf, and reflexive equivalentClass for classes")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@property soundness
      (forall (t $result)
        (exists (dt (. delta triples))
          (and
            (term-eq (triple-predicate dt) (make-iri arena RDF_TYPE))
            (term-eq (triple-object dt) (make-iri arena OWL_CLASS))
            (or
              ;; c subClassOf c
              (and (term-eq (triple-subject t) (triple-subject dt))
                   (term-eq (triple-object t) (triple-subject dt))
                   (term-eq (triple-predicate t) (make-iri arena RDFS_SUBCLASS_OF)))
              ;; c subClassOf owl:Thing
              (and (term-eq (triple-subject t) (triple-subject dt))
                   (term-eq (triple-object t) (make-iri arena OWL_THING))
                   (term-eq (triple-predicate t) (make-iri arena RDFS_SUBCLASS_OF)))
              ;; owl:Nothing subClassOf c
              (and (term-eq (triple-subject t) (make-iri arena OWL_NOTHING))
                   (term-eq (triple-object t) (triple-subject dt))
                   (term-eq (triple-predicate t) (make-iri arena RDFS_SUBCLASS_OF)))
              ;; c equivalentClass c
              (and (term-eq (triple-subject t) (triple-subject dt))
                   (term-eq (triple-object t) (triple-subject dt))
                   (term-eq (triple-predicate t) (make-iri arena OWL_EQUIVALENT_CLASS))))))))
    (@property completeness-reflexive
      (forall (dt (. delta triples))
        (or (not (term-eq (triple-predicate dt) (make-iri arena RDF_TYPE)))
            (not (term-eq (triple-object dt) (make-iri arena OWL_CLASS)))
            (indexed-graph-contains g
              (make-triple arena (triple-subject dt) (make-iri arena RDFS_SUBCLASS_OF) (triple-subject dt)))
            (list-contains $result
              (make-triple arena (triple-subject dt) (make-iri arena RDFS_SUBCLASS_OF) (triple-subject dt))))))
    (@property completeness-thing
      (forall (dt (. delta triples))
        (or (not (term-eq (triple-predicate dt) (make-iri arena RDF_TYPE)))
            (not (term-eq (triple-object dt) (make-iri arena OWL_CLASS)))
            (indexed-graph-contains g
              (make-triple arena (triple-subject dt) (make-iri arena RDFS_SUBCLASS_OF) (make-iri arena OWL_THING)))
            (list-contains $result
              (make-triple arena (triple-subject dt) (make-iri arena RDFS_SUBCLASS_OF) (make-iri arena OWL_THING))))))
    (@property completeness-nothing
      (forall (dt (. delta triples))
        (or (not (term-eq (triple-predicate dt) (make-iri arena RDF_TYPE)))
            (not (term-eq (triple-object dt) (make-iri arena OWL_CLASS)))
            (indexed-graph-contains g
              (make-triple arena (make-iri arena OWL_NOTHING) (make-iri arena RDFS_SUBCLASS_OF) (triple-subject dt)))
            (list-contains $result
              (make-triple arena (make-iri arena OWL_NOTHING) (make-iri arena RDFS_SUBCLASS_OF) (triple-subject dt))))))
    (@property completeness-equiv
      (forall (dt (. delta triples))
        (or (not (term-eq (triple-predicate dt) (make-iri arena RDF_TYPE)))
            (not (term-eq (triple-object dt) (make-iri arena OWL_CLASS)))
            (indexed-graph-contains g
              (make-triple arena (triple-subject dt) (make-iri arena OWL_EQUIVALENT_CLASS) (triple-subject dt)))
            (list-contains $result
              (make-triple arena (triple-subject dt) (make-iri arena OWL_EQUIVALENT_CLASS) (triple-subject dt))))))
    (@example
      ;; Graph: (Person type owl:Class)
      ;; Result: (Person subClassOf Person), (Person subClassOf owl:Thing),
      ;;         (owl:Nothing subClassOf Person), (Person equivalentClass Person)
      (arena (fixture-g-with-class arena) (fixture-delta-with-class arena))
      -> (list _ _ _ _))
    (let ((class-type (make-iri arena OWL_CLASS))
          (type-pred (make-iri arena RDF_TYPE))
          (subclass-pred (make-iri arena RDFS_SUBCLASS_OF))
          (equiv-pred (make-iri arena OWL_EQUIVALENT_CLASS))
          (thing (make-iri arena OWL_THING))
          (nothing (make-iri arena OWL_NOTHING))
          (mut result (list-new arena Triple)))

      (match (map-get (. delta by-predicate) type-pred)
        ((some pred-triples)
          (for-each (dt pred-triples)
            (when (term-eq (triple-object dt) class-type)
              (let ((class (triple-subject dt)))
                ;; Reflexive: c subClassOf c
                (let ((reflexive (make-triple arena class subclass-pred class)))
                  (when (not (indexed-graph-contains g reflexive))
                    (list-push result reflexive)))
                ;; c subClassOf owl:Thing
                (let ((to-thing (make-triple arena class subclass-pred thing)))
                  (when (not (indexed-graph-contains g to-thing))
                    (list-push result to-thing)))
                ;; owl:Nothing subClassOf c
                (let ((nothing-sub (make-triple arena nothing subclass-pred class)))
                  (when (not (indexed-graph-contains g nothing-sub))
                    (list-push result nothing-sub)))
                ;; Reflexive: c equivalentClass c
                (let ((refl-equiv (make-triple arena class equiv-pred class)))
                  (when (not (indexed-graph-contains g refl-equiv))
                    (list-push result refl-equiv)))))))
        ((none) (do)))

      result))

  ;; ============================================================
  ;; scm-sco: Transitivity of rdfs:subClassOf
  ;;
  ;; If (?c1 rdfs:subClassOf ?c2) and (?c2 rdfs:subClassOf ?c3)
  ;; then (?c1 rdfs:subClassOf ?c3)
  ;; ============================================================

  (fn scm-sco ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Compute transitive closure of subClassOf")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@post (all-triples-have-predicate $result RDFS_SUBCLASS_OF))
    (@property soundness
      (forall (t $result)
        (exists (dt (. delta triples))
          (and
            (term-eq (triple-predicate dt) (make-iri arena RDFS_SUBCLASS_OF))
            (term-eq (triple-predicate t) (make-iri arena RDFS_SUBCLASS_OF))
            (or
              ;; Forward: (c1 subClassOf c2) in delta, (c2 subClassOf c3) in graph → (c1 subClassOf c3)
              (and (term-eq (triple-subject t) (triple-subject dt))
                   (indexed-graph-contains g
                     (make-triple arena (triple-object dt) (make-iri arena RDFS_SUBCLASS_OF) (triple-object t))))
              ;; Backward: (c1 subClassOf c2) in delta, (c0 subClassOf c1) in graph → (c0 subClassOf c2)
              (and (term-eq (triple-object t) (triple-object dt))
                   (indexed-graph-contains g
                     (make-triple arena (triple-subject t) (make-iri arena RDFS_SUBCLASS_OF) (triple-subject dt)))))))))
    (@example
      ;; Graph: (A subClassOf B), (B subClassOf C)
      ;; Delta: (B subClassOf C)
      ;; Result: (A subClassOf C)
      (arena (fixture-g-chain arena) (fixture-delta-new-link arena))
      -> (list (make-triple arena (make-iri arena EX_A) (make-iri arena RDFS_SUBCLASS_OF) (make-iri arena EX_C))))
    (let ((subclass-pred (make-iri arena RDFS_SUBCLASS_OF))
          (no-term (Option Term) (none))
          (mut result (list-new arena Triple)))

      ;; For each subclass assertion in delta
      (match (map-get (. delta by-predicate) subclass-pred)
        ((some pred-triples)
          (for-each (dt pred-triples)
            (let ((c1 (triple-subject dt))
                  (c2 (triple-object dt)))
              ;; Find c2 subClassOf c3 (c2 as subject)
              (indexed-graph-for-each g (some c2) (some subclass-pred) no-term
                (fn ((super-triple Triple))
                  (let ((c3 (triple-object super-triple))
                        (inferred (make-triple arena c1 subclass-pred c3)))
                    (when (not (indexed-graph-contains g inferred))
                      (list-push result inferred)))))

              ;; Find c0 subClassOf c1 (c1 as object)
              (indexed-graph-for-each g no-term (some subclass-pred) (some c1)
                (fn ((sub-triple Triple))
                  (let ((c0 (triple-subject sub-triple))
                        (inferred (make-triple arena c0 subclass-pred c2)))
                    (when (not (indexed-graph-contains g inferred))
                      (list-push result inferred))))))))
        ((none) (do)))

      result))

  ;; ============================================================
  ;; scm-eqc1: Equivalent class implies mutual subclass (1)
  ;;
  ;; If (?c1 owl:equivalentClass ?c2)
  ;; then (?c1 rdfs:subClassOf ?c2)
  ;; ============================================================

  (fn scm-eqc1 ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Derive subClassOf from equivalentClass (c1 -> c2)")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@post (all-triples-have-predicate $result RDFS_SUBCLASS_OF))
    (@property soundness
      (forall (t $result)
        (exists (dt (. delta triples))
          (and
            (term-eq (triple-predicate dt) (make-iri arena OWL_EQUIVALENT_CLASS))
            (term-eq (triple-subject t) (triple-subject dt))
            (term-eq (triple-object t) (triple-object dt))
            (term-eq (triple-predicate t) (make-iri arena RDFS_SUBCLASS_OF))))))
    (@property completeness
      (forall (dt (. delta triples))
        (or (not (term-eq (triple-predicate dt) (make-iri arena OWL_EQUIVALENT_CLASS)))
            (indexed-graph-contains g
              (make-triple arena (triple-subject dt) (make-iri arena RDFS_SUBCLASS_OF) (triple-object dt)))
            (list-contains $result
              (make-triple arena (triple-subject dt) (make-iri arena RDFS_SUBCLASS_OF) (triple-object dt))))))
    (@example
      ;; Graph: (Human equivalentClass Person)
      ;; Result: (Human subClassOf Person)
      (arena (fixture-g-equiv arena) (fixture-delta-equiv arena))
      -> (list (make-triple arena (make-iri arena EX_HUMAN) (make-iri arena RDFS_SUBCLASS_OF) (make-iri arena EX_PERSON))))
    (let ((equiv-pred (make-iri arena OWL_EQUIVALENT_CLASS))
          (subclass-pred (make-iri arena RDFS_SUBCLASS_OF))
          (mut result (list-new arena Triple)))

      (match (map-get (. delta by-predicate) equiv-pred)
        ((some pred-triples)
          (for-each (dt pred-triples)
            (let ((c1 (triple-subject dt))
                  (c2 (triple-object dt))
                  (inferred (make-triple arena c1 subclass-pred c2)))
              (when (not (indexed-graph-contains g inferred))
                (list-push result inferred)))))
        ((none) (do)))

      result))

  ;; ============================================================
  ;; scm-eqc2: Equivalent class implies mutual subclass (2)
  ;;
  ;; If (?c1 owl:equivalentClass ?c2)
  ;; then (?c2 rdfs:subClassOf ?c1)
  ;; ============================================================

  (fn scm-eqc2 ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Derive subClassOf from equivalentClass (c2 -> c1)")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@post (all-triples-have-predicate $result RDFS_SUBCLASS_OF))
    (@property soundness
      (forall (t $result)
        (exists (dt (. delta triples))
          (and
            (term-eq (triple-predicate dt) (make-iri arena OWL_EQUIVALENT_CLASS))
            (term-eq (triple-subject t) (triple-object dt))
            (term-eq (triple-object t) (triple-subject dt))
            (term-eq (triple-predicate t) (make-iri arena RDFS_SUBCLASS_OF))))))
    (@property completeness
      (forall (dt (. delta triples))
        (or (not (term-eq (triple-predicate dt) (make-iri arena OWL_EQUIVALENT_CLASS)))
            (indexed-graph-contains g
              (make-triple arena (triple-object dt) (make-iri arena RDFS_SUBCLASS_OF) (triple-subject dt)))
            (list-contains $result
              (make-triple arena (triple-object dt) (make-iri arena RDFS_SUBCLASS_OF) (triple-subject dt))))))
    (@example
      ;; Graph: (Human equivalentClass Person)
      ;; Result: (Person subClassOf Human)
      (arena (fixture-g-equiv arena) (fixture-delta-equiv arena))
      -> (list (make-triple arena (make-iri arena EX_PERSON) (make-iri arena RDFS_SUBCLASS_OF) (make-iri arena EX_HUMAN))))
    (let ((equiv-pred (make-iri arena OWL_EQUIVALENT_CLASS))
          (subclass-pred (make-iri arena RDFS_SUBCLASS_OF))
          (mut result (list-new arena Triple)))

      (match (map-get (. delta by-predicate) equiv-pred)
        ((some pred-triples)
          (for-each (dt pred-triples)
            (let ((c1 (triple-subject dt))
                  (c2 (triple-object dt))
                  (inferred (make-triple arena c2 subclass-pred c1)))
              (when (not (indexed-graph-contains g inferred))
                (list-push result inferred)))))
        ((none) (do)))

      result))

  ;; ============================================================
  ;; scm-eqc-mutual: Mutual subClassOf implies equivalentClass
  ;;
  ;; If (?c1 rdfs:subClassOf ?c2) and (?c2 rdfs:subClassOf ?c1)
  ;; then (?c1 owl:equivalentClass ?c2)
  ;;
  ;; (W3C OWL 2 RL Table 9 "scm-eqc2")
  ;; ============================================================

  (fn scm-eqc-mutual ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Derive equivalentClass from mutual subClassOf")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@property soundness
      (forall (t $result)
        (exists (dt (. delta triples))
          (and
            (term-eq (triple-predicate dt) (make-iri arena RDFS_SUBCLASS_OF))
            (term-eq (triple-predicate t) (make-iri arena OWL_EQUIVALENT_CLASS))
            (term-eq (triple-subject t) (triple-subject dt))
            (term-eq (triple-object t) (triple-object dt))
            (not (term-eq (triple-subject dt) (triple-object dt)))
            (indexed-graph-contains g
              (make-triple arena (triple-object dt) (make-iri arena RDFS_SUBCLASS_OF) (triple-subject dt)))))))
    (@property completeness
      (forall (dt (. delta triples))
        (or (not (term-eq (triple-predicate dt) (make-iri arena RDFS_SUBCLASS_OF)))
            (term-eq (triple-subject dt) (triple-object dt))
            (not (indexed-graph-contains g
              (make-triple arena (triple-object dt) (make-iri arena RDFS_SUBCLASS_OF) (triple-subject dt))))
            (indexed-graph-contains g
              (make-triple arena (triple-subject dt) (make-iri arena OWL_EQUIVALENT_CLASS) (triple-object dt)))
            (list-contains $result
              (make-triple arena (triple-subject dt) (make-iri arena OWL_EQUIVALENT_CLASS) (triple-object dt))))))
    (let ((subclass-pred (make-iri arena RDFS_SUBCLASS_OF))
          (equiv-pred (make-iri arena OWL_EQUIVALENT_CLASS))
          (mut result (list-new arena Triple)))

      ;; For each new subClassOf: c1 subClassOf c2
      (match (map-get (. delta by-predicate) subclass-pred)
        ((some pred-triples)
          (for-each (dt pred-triples)
            (let ((c1 (triple-subject dt))
                  (c2 (triple-object dt)))
              ;; Skip reflexive (c subClassOf c) — would give trivial c eqc c
              ;; which scm-cls already handles
              (when (not (term-eq c1 c2))
                ;; Check if c2 subClassOf c1 exists in graph
                (let ((reverse (make-triple arena c2 subclass-pred c1)))
                  (when (indexed-graph-contains g reverse)
                    (let ((inferred (make-triple arena c1 equiv-pred c2)))
                      (when (not (indexed-graph-contains g inferred))
                        (list-push result inferred)))))))))
        ((none) (do)))

      result))

  ;; ============================================================
  ;; scm-op: Object property is subproperty of itself
  ;;
  ;; If (?p rdf:type owl:ObjectProperty)
  ;; then (?p rdfs:subPropertyOf ?p)
  ;; ============================================================

  (fn scm-op ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Infer reflexive subPropertyOf for object properties and rdf:Property")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@property soundness
      (forall (t $result)
        (exists (dt (. delta triples))
          (and
            (term-eq (triple-predicate dt) (make-iri arena RDF_TYPE))
            (or (term-eq (triple-object dt) (make-iri arena OWL_OBJECT_PROPERTY))
                (term-eq (triple-object dt) (make-iri arena RDF_PROPERTY)))
            (term-eq (triple-subject t) (triple-subject dt))
            (term-eq (triple-subject t) (triple-object t))
            (or (term-eq (triple-predicate t) (make-iri arena RDFS_SUBPROPERTY_OF))
                (term-eq (triple-predicate t) (make-iri arena OWL_EQUIVALENT_PROPERTY)))))))
    (@property completeness-subprop
      (forall (dt (. delta triples))
        (or (not (term-eq (triple-predicate dt) (make-iri arena RDF_TYPE)))
            (not (or (term-eq (triple-object dt) (make-iri arena OWL_OBJECT_PROPERTY))
                     (term-eq (triple-object dt) (make-iri arena RDF_PROPERTY))))
            (indexed-graph-contains g
              (make-triple arena (triple-subject dt) (make-iri arena RDFS_SUBPROPERTY_OF) (triple-subject dt)))
            (list-contains $result
              (make-triple arena (triple-subject dt) (make-iri arena RDFS_SUBPROPERTY_OF) (triple-subject dt))))))
    (@property completeness-equiv
      (forall (dt (. delta triples))
        (or (not (term-eq (triple-predicate dt) (make-iri arena RDF_TYPE)))
            (not (or (term-eq (triple-object dt) (make-iri arena OWL_OBJECT_PROPERTY))
                     (term-eq (triple-object dt) (make-iri arena RDF_PROPERTY))))
            (indexed-graph-contains g
              (make-triple arena (triple-subject dt) (make-iri arena OWL_EQUIVALENT_PROPERTY) (triple-subject dt)))
            (list-contains $result
              (make-triple arena (triple-subject dt) (make-iri arena OWL_EQUIVALENT_PROPERTY) (triple-subject dt))))))
    (let ((op-type (make-iri arena OWL_OBJECT_PROPERTY))
          (rdf-prop-type (make-iri arena RDF_PROPERTY))
          (type-pred (make-iri arena RDF_TYPE))
          (subprop-pred (make-iri arena RDFS_SUBPROPERTY_OF))
          (equiv-pred (make-iri arena OWL_EQUIVALENT_PROPERTY))
          (mut result (list-new arena Triple)))

      (match (map-get (. delta by-predicate) type-pred)
        ((some pred-triples)
          (for-each (dt pred-triples)
            (when (or (term-eq (triple-object dt) op-type)
                      (term-eq (triple-object dt) rdf-prop-type))
              (let ((prop (triple-subject dt)))
                ;; Reflexive: p subPropertyOf p
                (let ((reflexive (make-triple arena prop subprop-pred prop)))
                  (when (not (indexed-graph-contains g reflexive))
                    (list-push result reflexive)))
                ;; Reflexive: p equivalentProperty p
                (let ((refl-equiv (make-triple arena prop equiv-pred prop)))
                  (when (not (indexed-graph-contains g refl-equiv))
                    (list-push result refl-equiv)))))))
        ((none) (do)))

      result))

  ;; ============================================================
  ;; scm-dp: Datatype property is subproperty of itself
  ;;
  ;; If (?p rdf:type owl:DatatypeProperty)
  ;; then (?p rdfs:subPropertyOf ?p)
  ;; ============================================================

  (fn scm-dp ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Infer reflexive subPropertyOf for datatype properties")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@property soundness
      (forall (t $result)
        (exists (dt (. delta triples))
          (and
            (term-eq (triple-predicate dt) (make-iri arena RDF_TYPE))
            (term-eq (triple-object dt) (make-iri arena OWL_DATATYPE_PROPERTY))
            (term-eq (triple-subject t) (triple-subject dt))
            (term-eq (triple-subject t) (triple-object t))
            (or (term-eq (triple-predicate t) (make-iri arena RDFS_SUBPROPERTY_OF))
                (term-eq (triple-predicate t) (make-iri arena OWL_EQUIVALENT_PROPERTY)))))))
    (@property completeness-subprop
      (forall (dt (. delta triples))
        (or (not (term-eq (triple-predicate dt) (make-iri arena RDF_TYPE)))
            (not (term-eq (triple-object dt) (make-iri arena OWL_DATATYPE_PROPERTY)))
            (indexed-graph-contains g
              (make-triple arena (triple-subject dt) (make-iri arena RDFS_SUBPROPERTY_OF) (triple-subject dt)))
            (list-contains $result
              (make-triple arena (triple-subject dt) (make-iri arena RDFS_SUBPROPERTY_OF) (triple-subject dt))))))
    (@property completeness-equiv
      (forall (dt (. delta triples))
        (or (not (term-eq (triple-predicate dt) (make-iri arena RDF_TYPE)))
            (not (term-eq (triple-object dt) (make-iri arena OWL_DATATYPE_PROPERTY)))
            (indexed-graph-contains g
              (make-triple arena (triple-subject dt) (make-iri arena OWL_EQUIVALENT_PROPERTY) (triple-subject dt)))
            (list-contains $result
              (make-triple arena (triple-subject dt) (make-iri arena OWL_EQUIVALENT_PROPERTY) (triple-subject dt))))))
    (let ((dp-type (make-iri arena OWL_DATATYPE_PROPERTY))
          (type-pred (make-iri arena RDF_TYPE))
          (subprop-pred (make-iri arena RDFS_SUBPROPERTY_OF))
          (equiv-pred (make-iri arena OWL_EQUIVALENT_PROPERTY))
          (mut result (list-new arena Triple)))

      (match (map-get (. delta by-predicate) type-pred)
        ((some pred-triples)
          (for-each (dt pred-triples)
            (when (term-eq (triple-object dt) dp-type)
              (let ((prop (triple-subject dt)))
                ;; Reflexive: p subPropertyOf p
                (let ((reflexive (make-triple arena prop subprop-pred prop)))
                  (when (not (indexed-graph-contains g reflexive))
                    (list-push result reflexive)))
                ;; Reflexive: p equivalentProperty p
                (let ((refl-equiv (make-triple arena prop equiv-pred prop)))
                  (when (not (indexed-graph-contains g refl-equiv))
                    (list-push result refl-equiv)))))))
        ((none) (do)))

      result))

  ;; ============================================================
  ;; scm-spo: Transitivity of rdfs:subPropertyOf
  ;;
  ;; If (?p1 rdfs:subPropertyOf ?p2) and (?p2 rdfs:subPropertyOf ?p3)
  ;; then (?p1 rdfs:subPropertyOf ?p3)
  ;; ============================================================

  (fn scm-spo ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Compute transitive closure of subPropertyOf")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@post (all-triples-have-predicate $result RDFS_SUBPROPERTY_OF))
    (@property soundness
      (forall (t $result)
        (exists (dt (. delta triples))
          (and
            (term-eq (triple-predicate dt) (make-iri arena RDFS_SUBPROPERTY_OF))
            (term-eq (triple-predicate t) (make-iri arena RDFS_SUBPROPERTY_OF))
            (or
              ;; Forward: (p1 subPropOf p2) in delta, (p2 subPropOf p3) in graph → (p1 subPropOf p3)
              (and (term-eq (triple-subject t) (triple-subject dt))
                   (indexed-graph-contains g
                     (make-triple arena (triple-object dt) (make-iri arena RDFS_SUBPROPERTY_OF) (triple-object t))))
              ;; Backward: (p1 subPropOf p2) in delta, (p0 subPropOf p1) in graph → (p0 subPropOf p2)
              (and (term-eq (triple-object t) (triple-object dt))
                   (indexed-graph-contains g
                     (make-triple arena (triple-subject t) (make-iri arena RDFS_SUBPROPERTY_OF) (triple-subject dt)))))))))
    (@example
      ;; Graph: (hasFather subPropertyOf hasParent), (hasParent subPropertyOf hasAncestor)
      ;; Result: (hasFather subPropertyOf hasAncestor)
      (arena (fixture-g-prop-chain arena) (fixture-delta-subprop arena))
      -> (list (make-triple arena (make-iri arena EX_HAS_FATHER) (make-iri arena RDFS_SUBPROPERTY_OF) (make-iri arena EX_HAS_ANCESTOR))))
    (let ((subprop-pred (make-iri arena RDFS_SUBPROPERTY_OF))
          (no-term (Option Term) (none))
          (mut result (list-new arena Triple)))

      (match (map-get (. delta by-predicate) subprop-pred)
        ((some pred-triples)
          (for-each (dt pred-triples)
            (let ((p1 (triple-subject dt))
                  (p2 (triple-object dt)))
              ;; Find p2 subPropertyOf p3
              (indexed-graph-for-each g (some p2) (some subprop-pred) no-term
                (fn ((super-triple Triple))
                  (let ((p3 (triple-object super-triple))
                        (inferred (make-triple arena p1 subprop-pred p3)))
                    (when (not (indexed-graph-contains g inferred))
                      (list-push result inferred)))))

              ;; Find p0 subPropertyOf p1
              (indexed-graph-for-each g no-term (some subprop-pred) (some p1)
                (fn ((sub-triple Triple))
                  (let ((p0 (triple-subject sub-triple))
                        (inferred (make-triple arena p0 subprop-pred p2)))
                    (when (not (indexed-graph-contains g inferred))
                      (list-push result inferred))))))))
        ((none) (do)))

      result))

  ;; ============================================================
  ;; scm-eqp1: Equivalent property implies mutual subproperty (1)
  ;;
  ;; If (?p1 owl:equivalentProperty ?p2)
  ;; then (?p1 rdfs:subPropertyOf ?p2)
  ;; ============================================================

  (fn scm-eqp1 ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Derive subPropertyOf from equivalentProperty (p1 -> p2)")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@post (all-triples-have-predicate $result RDFS_SUBPROPERTY_OF))
    (@property soundness
      (forall (t $result)
        (exists (dt (. delta triples))
          (and
            (term-eq (triple-predicate dt) (make-iri arena OWL_EQUIVALENT_PROPERTY))
            (term-eq (triple-subject t) (triple-subject dt))
            (term-eq (triple-object t) (triple-object dt))
            (term-eq (triple-predicate t) (make-iri arena RDFS_SUBPROPERTY_OF))))))
    (@property completeness
      (forall (dt (. delta triples))
        (or (not (term-eq (triple-predicate dt) (make-iri arena OWL_EQUIVALENT_PROPERTY)))
            (indexed-graph-contains g
              (make-triple arena (triple-subject dt) (make-iri arena RDFS_SUBPROPERTY_OF) (triple-object dt)))
            (list-contains $result
              (make-triple arena (triple-subject dt) (make-iri arena RDFS_SUBPROPERTY_OF) (triple-object dt))))))
    (let ((equiv-pred (make-iri arena OWL_EQUIVALENT_PROPERTY))
          (subprop-pred (make-iri arena RDFS_SUBPROPERTY_OF))
          (mut result (list-new arena Triple)))

      (match (map-get (. delta by-predicate) equiv-pred)
        ((some pred-triples)
          (for-each (dt pred-triples)
            (let ((p1 (triple-subject dt))
                  (p2 (triple-object dt))
                  (inferred (make-triple arena p1 subprop-pred p2)))
              (when (not (indexed-graph-contains g inferred))
                (list-push result inferred)))))
        ((none) (do)))

      result))

  ;; ============================================================
  ;; scm-eqp2: Equivalent property implies mutual subproperty (2)
  ;;
  ;; If (?p1 owl:equivalentProperty ?p2)
  ;; then (?p2 rdfs:subPropertyOf ?p1)
  ;; ============================================================

  (fn scm-eqp2 ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Derive subPropertyOf from equivalentProperty (p2 -> p1)")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@post (all-triples-have-predicate $result RDFS_SUBPROPERTY_OF))
    (@property soundness
      (forall (t $result)
        (exists (dt (. delta triples))
          (and
            (term-eq (triple-predicate dt) (make-iri arena OWL_EQUIVALENT_PROPERTY))
            (term-eq (triple-subject t) (triple-object dt))
            (term-eq (triple-object t) (triple-subject dt))
            (term-eq (triple-predicate t) (make-iri arena RDFS_SUBPROPERTY_OF))))))
    (@property completeness
      (forall (dt (. delta triples))
        (or (not (term-eq (triple-predicate dt) (make-iri arena OWL_EQUIVALENT_PROPERTY)))
            (indexed-graph-contains g
              (make-triple arena (triple-object dt) (make-iri arena RDFS_SUBPROPERTY_OF) (triple-subject dt)))
            (list-contains $result
              (make-triple arena (triple-object dt) (make-iri arena RDFS_SUBPROPERTY_OF) (triple-subject dt))))))
    (let ((equiv-pred (make-iri arena OWL_EQUIVALENT_PROPERTY))
          (subprop-pred (make-iri arena RDFS_SUBPROPERTY_OF))
          (mut result (list-new arena Triple)))

      (match (map-get (. delta by-predicate) equiv-pred)
        ((some pred-triples)
          (for-each (dt pred-triples)
            (let ((p1 (triple-subject dt))
                  (p2 (triple-object dt))
                  (inferred (make-triple arena p2 subprop-pred p1)))
              (when (not (indexed-graph-contains g inferred))
                (list-push result inferred)))))
        ((none) (do)))

      result))

  ;; ============================================================
  ;; scm-eqp-mutual: Mutual subPropertyOf implies equivalentProperty
  ;;
  ;; If (?p1 rdfs:subPropertyOf ?p2) and (?p2 rdfs:subPropertyOf ?p1)
  ;; then (?p1 owl:equivalentProperty ?p2)
  ;;
  ;; (W3C OWL 2 RL Table 9 "scm-eqp2")
  ;; ============================================================

  (fn scm-eqp-mutual ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Derive equivalentProperty from mutual subPropertyOf")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@property soundness
      (forall (t $result)
        (exists (dt (. delta triples))
          (and
            (term-eq (triple-predicate dt) (make-iri arena RDFS_SUBPROPERTY_OF))
            (term-eq (triple-predicate t) (make-iri arena OWL_EQUIVALENT_PROPERTY))
            (term-eq (triple-subject t) (triple-subject dt))
            (term-eq (triple-object t) (triple-object dt))
            (not (term-eq (triple-subject dt) (triple-object dt)))
            (indexed-graph-contains g
              (make-triple arena (triple-object dt) (make-iri arena RDFS_SUBPROPERTY_OF) (triple-subject dt)))))))
    (@property completeness
      (forall (dt (. delta triples))
        (or (not (term-eq (triple-predicate dt) (make-iri arena RDFS_SUBPROPERTY_OF)))
            (term-eq (triple-subject dt) (triple-object dt))
            (not (indexed-graph-contains g
              (make-triple arena (triple-object dt) (make-iri arena RDFS_SUBPROPERTY_OF) (triple-subject dt))))
            (indexed-graph-contains g
              (make-triple arena (triple-subject dt) (make-iri arena OWL_EQUIVALENT_PROPERTY) (triple-object dt)))
            (list-contains $result
              (make-triple arena (triple-subject dt) (make-iri arena OWL_EQUIVALENT_PROPERTY) (triple-object dt))))))
    (let ((subprop-pred (make-iri arena RDFS_SUBPROPERTY_OF))
          (equiv-pred (make-iri arena OWL_EQUIVALENT_PROPERTY))
          (mut result (list-new arena Triple)))

      ;; For each new subPropertyOf: p1 subPropertyOf p2
      (match (map-get (. delta by-predicate) subprop-pred)
        ((some pred-triples)
          (for-each (dt pred-triples)
            (let ((p1 (triple-subject dt))
                  (p2 (triple-object dt)))
              ;; Skip reflexive (p subPropertyOf p)
              (when (not (term-eq p1 p2))
                ;; Check if p2 subPropertyOf p1 exists in graph
                (let ((reverse (make-triple arena p2 subprop-pred p1)))
                  (when (indexed-graph-contains g reverse)
                    (let ((inferred (make-triple arena p1 equiv-pred p2)))
                      (when (not (indexed-graph-contains g inferred))
                        (list-push result inferred)))))))))
        ((none) (do)))

      result))

  ;; ============================================================
  ;; scm-dom1: Domain inheritance via subproperty
  ;;
  ;; If (?p2 rdfs:domain ?c) and (?p1 rdfs:subPropertyOf ?p2)
  ;; then (?p1 rdfs:domain ?c)
  ;; ============================================================

  (fn scm-dom1 ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Inherit domain from superproperty")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@post (all-triples-have-predicate $result RDFS_DOMAIN))
    (@property soundness
      (forall (t $result)
        (exists (dt (. delta triples))
          (and
            (term-eq (triple-predicate dt) (make-iri arena RDFS_SUBPROPERTY_OF))
            (term-eq (triple-subject t) (triple-subject dt))
            (term-eq (triple-predicate t) (make-iri arena RDFS_DOMAIN))
            (indexed-graph-contains g
              (make-triple arena (triple-object dt) (make-iri arena RDFS_DOMAIN) (triple-object t)))))))
    (@example
      ;; Graph: (hasParent domain Person), (hasFather subPropertyOf hasParent)
      ;; Result: (hasFather domain Person)
      (arena (fixture-g-domain arena) (fixture-delta-subprop arena))
      -> (list (make-triple arena (make-iri arena EX_HAS_FATHER) (make-iri arena RDFS_DOMAIN) (make-iri arena EX_PERSON))))
    (let ((domain-pred (make-iri arena RDFS_DOMAIN))
          (subprop-pred (make-iri arena RDFS_SUBPROPERTY_OF))
          (no-term (Option Term) (none))
          (mut result (list-new arena Triple)))

      ;; For each new subPropertyOf assertion
      (match (map-get (. delta by-predicate) subprop-pred)
        ((some pred-triples)
          (for-each (dt pred-triples)
            (let ((p1 (triple-subject dt))
                  (p2 (triple-object dt)))
              ;; Find domain of p2
              (indexed-graph-for-each g (some p2) (some domain-pred) no-term
                (fn ((dom-triple Triple))
                  (let ((c (triple-object dom-triple))
                        (inferred (make-triple arena p1 domain-pred c)))
                    (when (not (indexed-graph-contains g inferred))
                      (list-push result inferred))))))))
        ((none) (do)))

      result))

  ;; ============================================================
  ;; scm-dom2: Domain constraint via subclass
  ;;
  ;; If (?p rdfs:domain ?c1) and (?c1 rdfs:subClassOf ?c2)
  ;; then (?p rdfs:domain ?c2)
  ;; ============================================================

  (fn scm-dom2 ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Propagate domain through subclass hierarchy")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@post (all-triples-have-predicate $result RDFS_DOMAIN))
    (@property soundness
      (forall (t $result)
        (exists (dt (. delta triples))
          (and
            (term-eq (triple-predicate dt) (make-iri arena RDFS_SUBCLASS_OF))
            (term-eq (triple-predicate t) (make-iri arena RDFS_DOMAIN))
            (term-eq (triple-object t) (triple-object dt))
            (indexed-graph-contains g
              (make-triple arena (triple-subject t) (make-iri arena RDFS_DOMAIN) (triple-subject dt)))))))
    (let ((domain-pred (make-iri arena RDFS_DOMAIN))
          (subclass-pred (make-iri arena RDFS_SUBCLASS_OF))
          (no-term (Option Term) (none))
          (mut result (list-new arena Triple)))

      ;; For each new subClassOf assertion
      (match (map-get (. delta by-predicate) subclass-pred)
        ((some pred-triples)
          (for-each (dt pred-triples)
            (let ((c1 (triple-subject dt))
                  (c2 (triple-object dt)))
              ;; Find properties with domain c1
              (indexed-graph-for-each g no-term (some domain-pred) (some c1)
                (fn ((dom-triple Triple))
                  (let ((p (triple-subject dom-triple))
                        (inferred (make-triple arena p domain-pred c2)))
                    (when (not (indexed-graph-contains g inferred))
                      (list-push result inferred))))))))
        ((none) (do)))

      result))

  ;; ============================================================
  ;; scm-rng1: Range inheritance via subproperty
  ;;
  ;; If (?p2 rdfs:range ?c) and (?p1 rdfs:subPropertyOf ?p2)
  ;; then (?p1 rdfs:range ?c)
  ;; ============================================================

  (fn scm-rng1 ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Inherit range from superproperty")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@post (all-triples-have-predicate $result RDFS_RANGE))
    (@property soundness
      (forall (t $result)
        (exists (dt (. delta triples))
          (and
            (term-eq (triple-predicate dt) (make-iri arena RDFS_SUBPROPERTY_OF))
            (term-eq (triple-subject t) (triple-subject dt))
            (term-eq (triple-predicate t) (make-iri arena RDFS_RANGE))
            (indexed-graph-contains g
              (make-triple arena (triple-object dt) (make-iri arena RDFS_RANGE) (triple-object t)))))))
    (let ((range-pred (make-iri arena RDFS_RANGE))
          (subprop-pred (make-iri arena RDFS_SUBPROPERTY_OF))
          (no-term (Option Term) (none))
          (mut result (list-new arena Triple)))

      (match (map-get (. delta by-predicate) subprop-pred)
        ((some pred-triples)
          (for-each (dt pred-triples)
            (let ((p1 (triple-subject dt))
                  (p2 (triple-object dt)))
              (indexed-graph-for-each g (some p2) (some range-pred) no-term
                (fn ((rng-triple Triple))
                  (let ((c (triple-object rng-triple))
                        (inferred (make-triple arena p1 range-pred c)))
                    (when (not (indexed-graph-contains g inferred))
                      (list-push result inferred))))))))
        ((none) (do)))

      result))

  ;; ============================================================
  ;; scm-rng2: Range constraint via subclass
  ;;
  ;; If (?p rdfs:range ?c1) and (?c1 rdfs:subClassOf ?c2)
  ;; then (?p rdfs:range ?c2)
  ;; ============================================================

  (fn scm-rng2 ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Propagate range through subclass hierarchy")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@post (all-triples-have-predicate $result RDFS_RANGE))
    (@property soundness
      (forall (t $result)
        (exists (dt (. delta triples))
          (and
            (term-eq (triple-predicate dt) (make-iri arena RDFS_SUBCLASS_OF))
            (term-eq (triple-predicate t) (make-iri arena RDFS_RANGE))
            (term-eq (triple-object t) (triple-object dt))
            (indexed-graph-contains g
              (make-triple arena (triple-subject t) (make-iri arena RDFS_RANGE) (triple-subject dt)))))))
    (let ((range-pred (make-iri arena RDFS_RANGE))
          (subclass-pred (make-iri arena RDFS_SUBCLASS_OF))
          (no-term (Option Term) (none))
          (mut result (list-new arena Triple)))

      (match (map-get (. delta by-predicate) subclass-pred)
        ((some pred-triples)
          (for-each (dt pred-triples)
            (let ((c1 (triple-subject dt))
                  (c2 (triple-object dt)))
              (indexed-graph-for-each g no-term (some range-pred) (some c1)
                (fn ((rng-triple Triple))
                  (let ((p (triple-subject rng-triple))
                        (inferred (make-triple arena p range-pred c2)))
                    (when (not (indexed-graph-contains g inferred))
                      (list-push result inferred))))))))
        ((none) (do)))

      result))

  ;; ============================================================
  ;; scm-int: Intersection implies subClassOf components
  ;;
  ;; If (?c owl:intersectionOf ?x) and LIST(?x, ?c1, ..., ?cn)
  ;; then (?c rdfs:subClassOf ?c1), ..., (?c rdfs:subClassOf ?cn)
  ;; ============================================================

  (fn scm-int ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Derive subClassOf from intersection to its components")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@post (all-triples-have-predicate $result RDFS_SUBCLASS_OF))
    (@property soundness
      (forall (t $result)
        (term-eq (triple-predicate t) (make-iri arena RDFS_SUBCLASS_OF))))
    (let ((intersection-pred (make-iri arena OWL_INTERSECTION_OF))
          (subclass-pred (make-iri arena RDFS_SUBCLASS_OF))
          (no-term (Option Term) (none))
          (mut result (list-new arena Triple)))

      ;; Trigger on new intersectionOf assertions in delta
      (match (map-get (. delta by-predicate) intersection-pred)
        ((some pred-triples)
          (for-each (dt pred-triples)
            (let ((int-class (triple-subject dt))
                  (list-head (triple-object dt))
                  (components (rdf-list-elements-indexed arena g list-head)))
              (for-each (comp components)
                (let ((inferred (make-triple arena int-class subclass-pred comp)))
                  (when (not (indexed-graph-contains g inferred))
                    (list-push result inferred)))))))
        ((none) (do)))

      ;; Also scan graph for existing intersectionOf definitions (triggered by first iteration)
      (indexed-graph-for-each g no-term (some intersection-pred) no-term
        (fn ((int-triple Triple))
          (let ((int-class (triple-subject int-triple))
                (list-head (triple-object int-triple))
                (components (rdf-list-elements-indexed arena g list-head)))
            (for-each (comp components)
              (let ((inferred (make-triple arena int-class subclass-pred comp)))
                (when (not (indexed-graph-contains g inferred))
                  (list-push result inferred)))))))

      result))

  ;; ============================================================
  ;; scm-uni: Union components are subClassOf the union
  ;;
  ;; If (?c owl:unionOf ?x) and LIST(?x, ?c1, ..., ?cn)
  ;; then (?c1 rdfs:subClassOf ?c), ..., (?cn rdfs:subClassOf ?c)
  ;; ============================================================

  (fn scm-uni ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Derive subClassOf from union components to the union class")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@post (all-triples-have-predicate $result RDFS_SUBCLASS_OF))
    (@property soundness
      (forall (t $result)
        (term-eq (triple-predicate t) (make-iri arena RDFS_SUBCLASS_OF))))
    (let ((union-pred (make-iri arena OWL_UNION_OF))
          (subclass-pred (make-iri arena RDFS_SUBCLASS_OF))
          (no-term (Option Term) (none))
          (mut result (list-new arena Triple)))

      ;; Trigger on new unionOf assertions in delta
      (match (map-get (. delta by-predicate) union-pred)
        ((some pred-triples)
          (for-each (dt pred-triples)
            (let ((union-class (triple-subject dt))
                  (list-head (triple-object dt))
                  (components (rdf-list-elements-indexed arena g list-head)))
              (for-each (comp components)
                (let ((inferred (make-triple arena comp subclass-pred union-class)))
                  (when (not (indexed-graph-contains g inferred))
                    (list-push result inferred)))))))
        ((none) (do)))

      ;; Also scan graph for existing unionOf definitions
      (indexed-graph-for-each g no-term (some union-pred) no-term
        (fn ((union-triple Triple))
          (let ((union-class (triple-subject union-triple))
                (list-head (triple-object union-triple))
                (components (rdf-list-elements-indexed arena g list-head)))
            (for-each (comp components)
              (let ((inferred (make-triple arena comp subclass-pred union-class)))
                (when (not (indexed-graph-contains g inferred))
                  (list-push result inferred)))))))

      result))

  ;; ============================================================
  ;; scm-svf1: someValuesFrom subclass via subclass of value type
  ;;
  ;; If (?c1 owl:someValuesFrom ?y1) on (?p) and
  ;;    (?c2 owl:someValuesFrom ?y2) on (?p) and
  ;;    (?y1 rdfs:subClassOf ?y2)
  ;; then (?c1 rdfs:subClassOf ?c2)
  ;; ============================================================

  (fn scm-svf1 ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Derive subClassOf from someValuesFrom restrictions with subclass value types")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@post (all-triples-have-predicate $result RDFS_SUBCLASS_OF))
    (@property soundness
      (forall (t $result)
        (exists (dt (. delta triples))
          (and
            (term-eq (triple-predicate t) (make-iri arena RDFS_SUBCLASS_OF))
            (term-eq (triple-predicate dt) (make-iri arena RDFS_SUBCLASS_OF))))))
    (let ((svf-pred (make-iri arena OWL_SOME_VALUES_FROM))
          (on-prop-pred (make-iri arena OWL_ON_PROPERTY))
          (subclass-pred (make-iri arena RDFS_SUBCLASS_OF))
          (no-term (Option Term) (none))
          (mut result (list-new arena Triple)))

      ;; Triggered by new subClassOf in delta: y1 subClassOf y2
      ;; Look up restrictions where y1 or y2 is the someValuesFrom value
      (match (map-get (. delta by-predicate) subclass-pred)
        ((some pred-triples)
          (for-each (dt pred-triples)
            (let ((y1 (triple-subject dt))
                  (y2 (triple-object dt)))
              ;; Find all restrictions with someValuesFrom y1 (these are c1 candidates)
              (indexed-graph-for-each g no-term (some svf-pred) (some y1)
                (fn ((svf1-triple Triple))
                  (let ((c1 (triple-subject svf1-triple)))
                    ;; Get the onProperty for c1
                    (indexed-graph-for-each g (some c1) (some on-prop-pred) no-term
                      (fn ((prop1-triple Triple))
                        (let ((p (triple-object prop1-triple)))
                          ;; Find restrictions with someValuesFrom y2 on same property p
                          (indexed-graph-for-each g no-term (some svf-pred) (some y2)
                            (fn ((svf2-triple Triple))
                              (let ((c2 (triple-subject svf2-triple)))
                                ;; Check c2 onProperty p
                                (let ((c2-on-p (make-triple arena c2 on-prop-pred p)))
                                  (when (indexed-graph-contains g c2-on-p)
                                    (let ((inferred (make-triple arena c1 subclass-pred c2)))
                                      (when (not (indexed-graph-contains g inferred))
                                        (list-push result inferred)))))))))))))))))
        ((none) (do)))

      result))

  ;; ============================================================
  ;; scm-svf2: someValuesFrom subclass via subproperty
  ;;
  ;; If (?c1 owl:someValuesFrom ?y) on (?p1) and
  ;;    (?c2 owl:someValuesFrom ?y) on (?p2) and
  ;;    (?p1 rdfs:subPropertyOf ?p2)
  ;; then (?c1 rdfs:subClassOf ?c2)
  ;; ============================================================

  (fn scm-svf2 ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Derive subClassOf from someValuesFrom restrictions with subproperty")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@post (all-triples-have-predicate $result RDFS_SUBCLASS_OF))
    (@property soundness
      (forall (t $result)
        (exists (dt (. delta triples))
          (and
            (term-eq (triple-predicate t) (make-iri arena RDFS_SUBCLASS_OF))
            (term-eq (triple-predicate dt) (make-iri arena RDFS_SUBPROPERTY_OF))))))
    (let ((svf-pred (make-iri arena OWL_SOME_VALUES_FROM))
          (on-prop-pred (make-iri arena OWL_ON_PROPERTY))
          (subprop-pred (make-iri arena RDFS_SUBPROPERTY_OF))
          (subclass-pred (make-iri arena RDFS_SUBCLASS_OF))
          (no-term (Option Term) (none))
          (mut result (list-new arena Triple)))

      ;; Triggered by new subPropertyOf: p1 subPropertyOf p2
      (match (map-get (. delta by-predicate) subprop-pred)
        ((some pred-triples)
          (for-each (dt pred-triples)
            (let ((p1 (triple-subject dt))
                  (p2 (triple-object dt)))
              ;; Find restrictions with onProperty p1
              (indexed-graph-for-each g no-term (some on-prop-pred) (some p1)
                (fn ((prop1-triple Triple))
                  (let ((c1 (triple-subject prop1-triple)))
                    ;; Get someValuesFrom for c1
                    (indexed-graph-for-each g (some c1) (some svf-pred) no-term
                      (fn ((svf1-triple Triple))
                        (let ((y (triple-object svf1-triple)))
                          ;; Find restrictions with onProperty p2 and someValuesFrom y
                          (indexed-graph-for-each g no-term (some on-prop-pred) (some p2)
                            (fn ((prop2-triple Triple))
                              (let ((c2 (triple-subject prop2-triple))
                                    (c2-svf-y (make-triple arena c2 svf-pred y)))
                                (when (indexed-graph-contains g c2-svf-y)
                                  (let ((inferred (make-triple arena c1 subclass-pred c2)))
                                    (when (not (indexed-graph-contains g inferred))
                                      (list-push result inferred))))))))))))))))
        ((none) (do)))

      result))

  ;; ============================================================
  ;; scm-avf1: allValuesFrom subclass via subclass of value type
  ;;
  ;; If (?c1 owl:allValuesFrom ?y1) on (?p) and
  ;;    (?c2 owl:allValuesFrom ?y2) on (?p) and
  ;;    (?y1 rdfs:subClassOf ?y2)
  ;; then (?c1 rdfs:subClassOf ?c2)
  ;; ============================================================

  (fn scm-avf1 ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Derive subClassOf from allValuesFrom restrictions with subclass value types")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@post (all-triples-have-predicate $result RDFS_SUBCLASS_OF))
    (@property soundness
      (forall (t $result)
        (exists (dt (. delta triples))
          (and
            (term-eq (triple-predicate t) (make-iri arena RDFS_SUBCLASS_OF))
            (term-eq (triple-predicate dt) (make-iri arena RDFS_SUBCLASS_OF))))))
    (let ((avf-pred (make-iri arena OWL_ALL_VALUES_FROM))
          (on-prop-pred (make-iri arena OWL_ON_PROPERTY))
          (subclass-pred (make-iri arena RDFS_SUBCLASS_OF))
          (no-term (Option Term) (none))
          (mut result (list-new arena Triple)))

      ;; Triggered by new subClassOf: y1 subClassOf y2
      (match (map-get (. delta by-predicate) subclass-pred)
        ((some pred-triples)
          (for-each (dt pred-triples)
            (let ((y1 (triple-subject dt))
                  (y2 (triple-object dt)))
              ;; Find restrictions with allValuesFrom y1
              (indexed-graph-for-each g no-term (some avf-pred) (some y1)
                (fn ((avf1-triple Triple))
                  (let ((c1 (triple-subject avf1-triple)))
                    ;; Get onProperty for c1
                    (indexed-graph-for-each g (some c1) (some on-prop-pred) no-term
                      (fn ((prop1-triple Triple))
                        (let ((p (triple-object prop1-triple)))
                          ;; Find restrictions with allValuesFrom y2 on same property
                          (indexed-graph-for-each g no-term (some avf-pred) (some y2)
                            (fn ((avf2-triple Triple))
                              (let ((c2 (triple-subject avf2-triple)))
                                (let ((c2-on-p (make-triple arena c2 on-prop-pred p)))
                                  (when (indexed-graph-contains g c2-on-p)
                                    (let ((inferred (make-triple arena c1 subclass-pred c2)))
                                      (when (not (indexed-graph-contains g inferred))
                                        (list-push result inferred)))))))))))))))))
        ((none) (do)))

      result))

  ;; ============================================================
  ;; scm-avf2: allValuesFrom subclass via subproperty (REVERSED)
  ;;
  ;; If (?c1 owl:allValuesFrom ?y) on (?p1) and
  ;;    (?c2 owl:allValuesFrom ?y) on (?p2) and
  ;;    (?p1 rdfs:subPropertyOf ?p2)
  ;; then (?c2 rdfs:subClassOf ?c1)   ← NOTE reversed direction
  ;; ============================================================

  (fn scm-avf2 ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Derive subClassOf from allValuesFrom restrictions with subproperty (reversed)")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@post (all-triples-have-predicate $result RDFS_SUBCLASS_OF))
    (@property soundness
      (forall (t $result)
        (exists (dt (. delta triples))
          (and
            (term-eq (triple-predicate t) (make-iri arena RDFS_SUBCLASS_OF))
            (term-eq (triple-predicate dt) (make-iri arena RDFS_SUBPROPERTY_OF))))))
    (let ((avf-pred (make-iri arena OWL_ALL_VALUES_FROM))
          (on-prop-pred (make-iri arena OWL_ON_PROPERTY))
          (subprop-pred (make-iri arena RDFS_SUBPROPERTY_OF))
          (subclass-pred (make-iri arena RDFS_SUBCLASS_OF))
          (no-term (Option Term) (none))
          (mut result (list-new arena Triple)))

      ;; Triggered by new subPropertyOf: p1 subPropertyOf p2
      (match (map-get (. delta by-predicate) subprop-pred)
        ((some pred-triples)
          (for-each (dt pred-triples)
            (let ((p1 (triple-subject dt))
                  (p2 (triple-object dt)))
              ;; Find restrictions with onProperty p1
              (indexed-graph-for-each g no-term (some on-prop-pred) (some p1)
                (fn ((prop1-triple Triple))
                  (let ((c1 (triple-subject prop1-triple)))
                    ;; Get allValuesFrom for c1
                    (indexed-graph-for-each g (some c1) (some avf-pred) no-term
                      (fn ((avf1-triple Triple))
                        (let ((y (triple-object avf1-triple)))
                          ;; Find restrictions with onProperty p2 and allValuesFrom y
                          (indexed-graph-for-each g no-term (some on-prop-pred) (some p2)
                            (fn ((prop2-triple Triple))
                              (let ((c2 (triple-subject prop2-triple))
                                    (c2-avf-y (make-triple arena c2 avf-pred y)))
                                ;; NOTE: reversed direction - c2 subClassOf c1
                                (when (indexed-graph-contains g c2-avf-y)
                                  (let ((inferred (make-triple arena c2 subclass-pred c1)))
                                    (when (not (indexed-graph-contains g inferred))
                                      (list-push result inferred))))))))))))))))
        ((none) (do)))

      result))

  ;; ============================================================
  ;; scm-hv: hasValue subclass via subproperty
  ;;
  ;; If (?c1 owl:hasValue ?i) on (?p1) and
  ;;    (?c2 owl:hasValue ?i) on (?p2) and
  ;;    (?p1 rdfs:subPropertyOf ?p2)
  ;; then (?c1 rdfs:subClassOf ?c2)
  ;; ============================================================

  (fn scm-hv ((arena Arena) (g IndexedGraph) (delta Delta))
    (@intent "Derive subClassOf from hasValue restrictions with subproperty")
    (@spec ((Arena IndexedGraph Delta) -> (List Triple)))
    (@alloc arena)
    (@pure)
    (@pre {(indexed-graph-size g) >= 0})
    (@post {(list-len $result) >= 0})
    (@post (all-triples-have-predicate $result RDFS_SUBCLASS_OF))
    (@property soundness
      (forall (t $result)
        (exists (dt (. delta triples))
          (and
            (term-eq (triple-predicate t) (make-iri arena RDFS_SUBCLASS_OF))
            (term-eq (triple-predicate dt) (make-iri arena RDFS_SUBPROPERTY_OF))))))
    (let ((hv-pred (make-iri arena OWL_HAS_VALUE))
          (on-prop-pred (make-iri arena OWL_ON_PROPERTY))
          (subprop-pred (make-iri arena RDFS_SUBPROPERTY_OF))
          (subclass-pred (make-iri arena RDFS_SUBCLASS_OF))
          (no-term (Option Term) (none))
          (mut result (list-new arena Triple)))

      ;; Triggered by new subPropertyOf: p1 subPropertyOf p2
      (match (map-get (. delta by-predicate) subprop-pred)
        ((some pred-triples)
          (for-each (dt pred-triples)
            (let ((p1 (triple-subject dt))
                  (p2 (triple-object dt)))
              ;; Find restrictions with onProperty p1
              (indexed-graph-for-each g no-term (some on-prop-pred) (some p1)
                (fn ((prop1-triple Triple))
                  (let ((c1 (triple-subject prop1-triple)))
                    ;; Get hasValue for c1
                    (indexed-graph-for-each g (some c1) (some hv-pred) no-term
                      (fn ((hv1-triple Triple))
                        (let ((i (triple-object hv1-triple)))
                          ;; Find restrictions with onProperty p2 and hasValue i
                          (indexed-graph-for-each g no-term (some on-prop-pred) (some p2)
                            (fn ((prop2-triple Triple))
                              (let ((c2 (triple-subject prop2-triple))
                                    (c2-hv-i (make-triple arena c2 hv-pred i)))
                                (when (indexed-graph-contains g c2-hv-i)
                                  (let ((inferred (make-triple arena c1 subclass-pred c2)))
                                    (when (not (indexed-graph-contains g inferred))
                                      (list-push result inferred))))))))))))))))
        ((none) (do)))

      result)))
